<!DOCTYPE html>
<html lang="ch">

<head>
    <meta charset="UTF-8">
    <meta name="Author" content="Gatongone">
    <meta name="Description" content="Gatongone's Blog">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/x-icon"  href="/images/NeonGame_L.ico">
    <link rel="icon" type="image/x-icon"  href="/images/NeonGame_M.ico">
    <link rel="icon" type="image/x-icon"  href="/images/NeonGame_S.ico">
    <style>
        body
        {
            background-color: rgb(20, 20, 34);
            -ms-overflow-style: none; /* IE 10+ */
            scrollbar-width: none; /* Firefox */
            overflow-x: hidden;
            height: 100%;
        }
        body::-webkit-scrollbar
        {
            display: auto; /* Chrome Safari */
            width: 0px;
        }
    </style>
<meta name="generator" content="Hexo 5.3.0"></head>

    <body>
        
<link rel="stylesheet" href="/blog/css/leftsidebar.css">

<div class="leftpanel_out" id="leftpanel_out">
    <div class="block1"></div>

    <div class="profile_background" id="profile_background">
        <a href="/blog/" target="_self">
            <img class="profile" src="/blog/images/profile.jpg" />
        </a>
    </div>

    <img class="block2" src="/blog/images/block.png"/>

    <div class="buttons">
        <a>
           
        </a>
        <a target="_blank" rel="noopener" href="https://space.bilibili.com/26209665" title="bilibili">
            <img class="shadowfilter bilibili" src="/blog/images/icon/bilibili_btn.png"/>
        </a>
         <a>
           
        </a>
        <a target="_blank" rel="noopener" href="https://gatongone.lofter.com/" title="lofter">
            <img class="shadowfilter lofter" src="/blog/images/icon/lofter_btn.png"/>
        </a>
         <a>
           
        </a>
         <a target="_blank" rel="noopener" href="https://github.com/Gatongone/" title="github">
            <img class="shadowfilter github" src="/blog/images/icon/github_btn.png"/>
        </a>
         <a>
           
        </a>
        <a target="_blank" rel="noopener" href="https://blog.csdn.net/Gatongone" title="CSDN">
            <img class="shadowfilter csdn" src="/blog/images/icon/csdn_btn.png"/>
        </a>
    </div>
    <div class="block3"></div>
</div>
<script>
    // var obj=document.getElementById('leftpanel_out');
    // MoveBar(obj,"leftpanel_in",1150)
</script>                       <!-- 加载侧边栏 -->

        <div class='body-wrapper' id="body-wrapper">

            <head>
 <link rel="icon" type="image/x-icon"  href="/images/NeonGame_L.ico">
 <link rel="icon" type="image/x-icon"  href="/images/NeonGame_M.ico">
 <link rel="icon" type="image/x-icon"  href="/images/NeonGame_S.ico">
 <link href="https://cdn.bootcss.com/KaTeX/0.7.1/katex.min.css" rel="stylesheet">
 
</head>
<body>
    
<link rel="stylesheet" href="/blog/css/topbar.css">


<script src="/blog/js/searchbar.js"></script>
  
<div class="topbar" id="topbar">
    <div class = "top_left" id="top_left">
    <a href="https://www.gatongone.site" target="_self">
        <img src="/blog/images/NeonGame.png"/>
    </a>
        <font class="title_top" id="title_top" align="left">Gatongone's blog</font>
    </div>
    <div id="topblock">
            <nav>
                <input type="checkbox" id="nav"/><label for="nav" class="check" id="check"></label>
                <ul>
                    <li><a href="#" id='about' class="buttonfont">About</a></li>
                    <li><a href="#" id="plan" class="buttonfont">Planing</a></li>
                    <li><a href="#" id="RSS" class="buttonfont">RSS</a></li>
                </ul>
            </nav>
    </div>
    <div id="search">
        <input id="search_input"  type="text" placeholder="search with title" value="" onkeydown=" if(event.which==13)''">
        <button><img src="/blog/images/icon/search.png" style="height: 16px; width: 18px; margin-top: 2px;"></button>
    </div>
</div>

<!-- swiftype search -->

<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');
  
  _st('install','ZLY73zc1DgdsrmGd9LyN','2.0.0');
</script>



<script src="/blog/js/hidebar.js"></script>

    
<link rel="stylesheet" href="/blog/css/mainbody.css">


<!-- 回到首页 -->

    <a href="/blog/">
    <button class="home_btn" >
        <img src="/blog/images/icon/home.png">
    </button>
    </a>


<!-- 回到顶部 -->
<div id="top">
    <button class="top_btn" id="top_btn">
        <img src="/blog/images/icon/top.png">
    </button>
</div>
<!-- 主体 -->

<div class="mainbody" id="mainbody">
<!-- 加载post_entry -->
    <div class="entry">
    

    
<!--    加载post    -->    

    
        <head>
    <title>C#流Stream</title>
    <link rel="icon" type="image/x-icon"  href="/images/NeonGame_L.ico">
    <link rel="icon" type="image/x-icon"  href="/images/NeonGame_M.ico">
    <link rel="icon" type="image/x-icon"  href="/images/NeonGame_S.ico">
</head>
<body>

    
<link rel="stylesheet" href="/blog/css/post.css">

    
<link rel="stylesheet" href="/blog/css/hightlight.css">


    
<link rel="stylesheet" href="/blog/css/rightbar.css">

<div id="right_bar">

        

        
            <div id="post_index" class="post_index">
                <span> Post Index </span>
                <div>
                    <div id="clear"></div>
                    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#stream"><span class="toc-text"> Stream</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#filestream"><span class="toc-text"> FileStream</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E4%B8%AA%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-text"> 三个枚举类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text"> 常用构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="toc-text"> 写文件操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="toc-text"> 读文件操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#textwriter-textreader"><span class="toc-text"> TextWriter、TextReader</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#textwriter"><span class="toc-text"> TextWriter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#textreader"><span class="toc-text"> TextReader</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#streamwriter"><span class="toc-text"> StreamWriter</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-2"><span class="toc-text"> 常用构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text"> 常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C-2"><span class="toc-text"> 写文件操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#streamreader"><span class="toc-text"> StreamReader</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-3"><span class="toc-text"> 常用构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-2"><span class="toc-text"> 常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C-2"><span class="toc-text"> 读文件操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%B5%81"><span class="toc-text"> 其他流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#binaryreaderbinarywriter"><span class="toc-text"> BinaryReader&#x2F;BinaryWriter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#networkstream"><span class="toc-text"> NetworkStream</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#memorystream"><span class="toc-text"> MemoryStream</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cryptostream"><span class="toc-text"> CryptoStream</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bufferedstream"><span class="toc-text"> BufferedStream</span></a></li></ol></li></ol>
                </div>
                
             </div>
        
             
</div>


    <div class="page_title" id="page_title">
        C#流Stream
    </div>
    <hr>
    <div class="page_content">
        
        
        <p>流的本质都是字节文件，而之所以划分成字节流和字符流，是由于使用场景不同而导致的。</p>
<ul>
<li>字节流：用于处理二进制对象</li>
<li>字符流：用于处理字符或字符串</li>
</ul>
<p>字符流本质上只是对字节流进行字符集化，也就是根据不同的encode来进行处理。</p>
<p>也就是说<code>字符流是字节流的子集</code>。因此，所有能用字符流处理的情况都能用字节流处理，只不过会增加字符集化这部分操作。而字符流的写入过程就是将字符编码成字节，再将字节存储到磁盘中；字符流的读取过程就是将读取的字节再翻译成字符的过程。</p>
<p><code>流的读取和写入结束后都需要关闭流</code>,因为IO设备在打开时会占用资源，当声明一个流的读取或写入后，它将持续对资源进行占用。可以通过<code>Close()</code>(只关闭流)、<code>Dispose()</code>(关闭流并清理资源)、<code>using()&#123;&#125;</code>(本质上是在{}结束后调用Dispose()) 来对流进行关闭。</p>
<hr />
<ul>
<li>
<h2 id="stream"><a class="markdownIt-Anchor" href="#stream"></a> Stream</h2>
<p>提供了<code>字节流</code>的读写方法,并且在.net中将自带缓存池</p>
<ul>
<li>
<p>常用的属性</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>bool</td>
<td>CanRead</td>
<td>判断流是否可读</td>
</tr>
<tr>
<td>bool</td>
<td>CanWrite</td>
<td>判断流是否可写</td>
</tr>
<tr>
<td>bool</td>
<td>CanSeek</td>
<td>判断流是否支持跟踪查找</td>
</tr>
<tr>
<td>long</td>
<td>Length</td>
<td>流字节长度</td>
</tr>
<tr>
<td>long</td>
<td>Position</td>
<td>流的当前位置，根据缓冲池变动，读/写文件时将从这个位置开始，一般用于记录读取/写入了多少</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>常用的方法：</p>
<ul>
<li>
<p>void Flush()<br />
当使用流写入文件时，并不会直接写入而是先进入到缓冲池中，调用该方法则立即将缓冲池中字节推出</p>
</li>
<li>
<p>long Seek(long offset, SeekOrigin origin)<br />
由于Position是只读的，若希望重新设置Position的值，则需要调用Seek方法，其中SeekOrigin是一个枚举</p>
<table>
<thead>
<tr>
<th>枚举</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>SeekOrigin.Begin</td>
<td>流的开始位置</td>
</tr>
<tr>
<td>SeekOrigin.Current</td>
<td>流的当前位置</td>
</tr>
<tr>
<td>SeekOrigin.End</td>
<td>流的结束位置</td>
</tr>
</tbody>
</table>
<p><code>stream.Seek(5, SeekOrigin.Begin);</code>的含义就是将Position设置在开始位置后的第五个。</p>
</li>
<li>
<p>void Close()<br />
关闭流，但不会立即清理资源</p>
</li>
<li>
<p>void Dispose()<br />
关闭流并清理资源</p>
</li>
<li>
<p>void CopyTo(Stream destination)<br />
将流拷贝到目标流</p>
</li>
<li>
<p>int Read(byte[] buffer, int offset, int count)<br />
从offest(开始位置)读取出count个字节，并将读取的字节赋值给buffer，返回值是总共读取了多少个字节</p>
</li>
<li>
<p>void Write(byte[] buffer,int offset,int count)<br />
根据offest和count将buffer中的数据写入流中</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr />
<ul>
<li>
<h2 id="filestream"><a class="markdownIt-Anchor" href="#filestream"></a> FileStream</h2>
<p>继承至<code>Stream</code>,针对<code>本地文件</code>的流操作,该类提供了对<code>字节流</code>进行读写的方法</p>
<ul>
<li>
<h3 id="三个枚举类型"><a class="markdownIt-Anchor" href="#三个枚举类型"></a> 三个枚举类型</h3>
<ol>
<li>
<p>文件访问方式（打开文件后该干嘛）</p>
<table>
<thead>
<tr>
<th>枚举</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>FileAccess.Read</td>
<td>只读</td>
</tr>
<tr>
<td>FileAccess.Write</td>
<td>只写</td>
</tr>
<tr>
<td>FileAccess.ReadWrite</td>
<td>即可读又可写</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>文件操作模式</p>
<table>
<thead>
<tr>
<th>枚举</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>FileMode.Append</td>
<td>在文件最末尾追加数据，FileAccess必须是可读的</td>
</tr>
<tr>
<td>FileMode.Create</td>
<td>创建文件，如果已存在则覆盖</td>
</tr>
<tr>
<td>FileMode.CreateNew</td>
<td>创建文件，如果已存在则引发异常</td>
</tr>
<tr>
<td>FileMode.Open</td>
<td>打开文件，根据FileAccess打开后该干嘛</td>
</tr>
<tr>
<td>FileMode.OpenOrCreate</td>
<td>如果文件存在则打开，否则创建并打开</td>
</tr>
<tr>
<td>FileMode.Truncat</td>
<td>打开文件,并清空内容</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>文件共享方式（有其他程序同时访问时怎么处理）</p>
<table>
<thead>
<tr>
<th>枚举</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>FileShare.None</td>
<td>禁止其他程序读写文件</td>
</tr>
<tr>
<td>FileShare.Read</td>
<td>允许其他程序只读文件</td>
</tr>
<tr>
<td>FileShare.Write</td>
<td>允许其他程序只写文件</td>
</tr>
<tr>
<td>FileShare.ReadWrite</td>
<td>允许其他程序读写文件</td>
</tr>
</tbody>
</table>
</li>
</ol>
</li>
<li>
<h3 id="常用构造函数"><a class="markdownIt-Anchor" href="#常用构造函数"></a> 常用构造函数</h3>
<ul>
<li>FileStream（String 文件路径，FileMode 文件打开模式）</li>
<li>FileStream（String 文件路径，FileMode 文件打开模式，FileAccess 文件访问方式）</li>
<li>FileStream（String 文件路径，FileMode 文件打开模式，FileAccess 文件访问方式，FileShare 文件共享方式）</li>
</ul>
</li>
<li>
<h3 id="写文件操作"><a class="markdownIt-Anchor" href="#写文件操作"></a> 写文件操作</h3>
</li>
</ul>
<pre class="highlight"><code class="C#"><span class="hljs-keyword">string</span> path = <span class="hljs-string">@"E:\khaki\Markdown\test.txt"</span>;

<span class="hljs-keyword">using</span> (FileStream writer = File.Open(path, FileMode.OpenOrCreate,FileAccess.Write))
&#123;
    <span class="hljs-keyword">string</span> str = <span class="hljs-string">"这是一句测试用的话"</span>;

    <span class="hljs-comment">//把一组UTF-8编码的字符串 编码成 字节序列</span>
    <span class="hljs-keyword">byte</span>[] data = <span class="hljs-keyword">new</span> UTF8Encoding().GetBytes(str);
    <span class="hljs-comment">//写入到文件中</span>
    <span class="hljs-comment">//因为.net中stream自带缓存池，因此不需要像java那样准备一个缓存池</span>
    writer.Write(data, <span class="hljs-number">0</span>, data.Length);
    writer.Flush();
&#125;
</code></pre>
<ul>
<li>
<h3 id="读文件操作"><a class="markdownIt-Anchor" href="#读文件操作"></a> 读文件操作</h3>
</li>
</ul>
<pre class="highlight"><code class="C#"><span class="hljs-keyword">string</span> path = <span class="hljs-string">@"E:\khaki\Markdown\test.txt"</span>;
<span class="hljs-keyword">using</span> (FileStream reader = File.Open(path, FileMode.Open,FileAccess.Read))
&#123;
    <span class="hljs-comment">//得到文件长度</span>
    <span class="hljs-keyword">int</span> length = (<span class="hljs-keyword">int</span>)reader.Length;
    <span class="hljs-comment">//一个暂存池</span>
    <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[length];
    <span class="hljs-comment">//将读取后的字节放入暂存池，返回读入缓冲区的字节总数</span>
    <span class="hljs-keyword">int</span> r =  reader.Read(buffer, <span class="hljs-number">0</span>, length);
    <span class="hljs-comment">//以UTF-8编码成字符串</span>
    <span class="hljs-keyword">string</span> info = Encoding.UTF8.GetString(buffer, <span class="hljs-number">0</span>, r);
&#125;
</code></pre>
</li>
</ul>
<hr />
<ul>
<li>
<h2 id="textwriter-textreader"><a class="markdownIt-Anchor" href="#textwriter-textreader"></a> TextWriter、TextReader</h2>
<ul>
<li>
<h3 id="textwriter"><a class="markdownIt-Anchor" href="#textwriter"></a> TextWriter</h3>
</li>
</ul>
提供对连续<code>字符</code>的写入，以及将各种类型（int、boolean、char[]等）以字符形式写入流的方法
<ul>
<li>
<h3 id="textreader"><a class="markdownIt-Anchor" href="#textreader"></a> TextReader</h3>
</li>
</ul>
提供对连续<code>字符</code>的读取</li>
</ul>
<hr />
<ul>
<li>
<h2 id="streamwriter"><a class="markdownIt-Anchor" href="#streamwriter"></a> StreamWriter</h2>
<p>继承至TextWriter,提供了以<code>特定编码（默认为UTF-8）</code>对连续<code>字符</code>进行写入的方法</p>
<ul>
<li>
<h3 id="常用构造函数-2"><a class="markdownIt-Anchor" href="#常用构造函数-2"></a> 常用构造函数</h3>
<table>
<thead>
<tr>
<th>构造函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>StreamWriter(string path)</td>
<td>根据路径写入</td>
</tr>
<tr>
<td>StreamWriter(string path, bool append)</td>
<td>append是否在末尾加入</td>
</tr>
<tr>
<td>StreamWriter(string path, bool append, Encoding encoding)</td>
<td>encoding以何种编码写入</td>
</tr>
<tr>
<td>StreamWriter(string path, bool append, Encoding encoding, int bufferSize)</td>
<td>bufferSize缓冲区大小</td>
</tr>
<tr>
<td>StreamWriter(string stream)</td>
<td>根据流写入</td>
</tr>
<tr>
<td>StreamWriter(Stream stream, Encoding encoding)</td>
<td>encoding以何种编码写入</td>
</tr>
<tr>
<td>StreamWriter(Stream stream, Encoding encoding, int bufferSize)</td>
<td>bufferSize缓冲区大小</td>
</tr>
</tbody>
</table>
</li>
<li>
<h3 id="常用方法"><a class="markdownIt-Anchor" href="#常用方法"></a> 常用方法</h3>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Write(string value)</td>
<td>将字符串写入流</td>
</tr>
<tr>
<td>Write(string format, params Object[] arg)</td>
<td>将可变长参数arg进行format格式化并写入流</td>
</tr>
<tr>
<td>WriteLine()</td>
<td>向当于写入一个换行</td>
</tr>
<tr>
<td>WriteLine(string value)</td>
<td>写入一行字符串</td>
</tr>
<tr>
<td>WriteLine(string format, params Object[] arg)</td>
<td>将可变长参数arg进行format格式化并以一行写入流</td>
</tr>
</tbody>
</table>
</li>
<li>
<h3 id="写文件操作-2"><a class="markdownIt-Anchor" href="#写文件操作-2"></a> 写文件操作</h3>
<p>直接根据路径进行写入：一般用在不需要对流进行访问权限、文件操作、文件共享时</p>
<pre class="highlight"><code class="C#"><span class="hljs-keyword">string</span> path = <span class="hljs-string">@"E:\khaki\Markdown\test.txt"</span>;
<span class="hljs-keyword">using</span> (StreamWriter writer = <span class="hljs-keyword">new</span> StreamWriter(path))
&#123;
    writer.WriteLine(<span class="hljs-string">"这是一句测试用的话"</span>);
&#125;
</code></pre>
<p>根据流进行写入</p>
<pre class="highlight"><code class="C#"><span class="hljs-keyword">string</span> path = <span class="hljs-string">@"E:\khaki\Markdown\test.txt"</span>;
<span class="hljs-keyword">using</span> (FileStream fs = <span class="hljs-keyword">new</span> FileStream(path, FileMode.Append, FileAccess.Write))
&#123;
    <span class="hljs-keyword">using</span> (StreamWriter sw = <span class="hljs-keyword">new</span> StreamWriter(fs))
    &#123;
        sw.WriteLine(<span class="hljs-string">"这是一条测试信息"</span>);
    &#125;
&#125;  
</code></pre>
</li>
</ul>
</li>
</ul>
<hr />
<ul>
<li>
<h2 id="streamreader"><a class="markdownIt-Anchor" href="#streamreader"></a> StreamReader</h2>
继承至TextReader,提供了以<code>特定编码（默认为UTF-8）</code>对连续<code>字符</code>进行读取并将数据写入缓冲区的方法
<ul>
<li>
<h3 id="常用构造函数-3"><a class="markdownIt-Anchor" href="#常用构造函数-3"></a> 常用构造函数</h3>
<table>
<thead>
<tr>
<th>构造函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>StreamReader(string path)</td>
<td>根据路径读取</td>
</tr>
<tr>
<td>StreamReader(string path, Encoding encoding)</td>
<td>encoding以何种编码读取</td>
</tr>
<tr>
<td>StreamReader(string path, Encoding encoding, bool detectEncodingFromByteOrderMarks)</td>
<td>detectEncodingFromByteOrderMarks是否自动判断用何种编码读取</td>
</tr>
<tr>
<td>StreamReader(string path, Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize)</td>
<td>BufferSize缓冲区大小</td>
</tr>
<tr>
<td>StreamReader(Stream stream)</td>
<td>根据流读取</td>
</tr>
<tr>
<td>StreamReader(Stream stream, Encoding encoding)</td>
<td>encoding以何种编码读取</td>
</tr>
<tr>
<td>StreamReader(Stream stream, Encoding encoding, bool detectEncodingFromByteOrderMarks)</td>
<td>detectEncodingFromByteOrderMarks是否自动判断用何种编码读取</td>
</tr>
<tr>
<td>StreamReader(Stream stream, Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize)</td>
<td>BufferSize缓冲区大小</td>
</tr>
</tbody>
</table>
</li>
<li>
<h3 id="常用方法-2"><a class="markdownIt-Anchor" href="#常用方法-2"></a> 常用方法</h3>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Peek()</td>
<td>寻找当前字符的下个字符,当返回值是-1时，表示是最后一个字符</td>
</tr>
<tr>
<td>Read()</td>
<td>读取下一个字符, 但是和peek方法不同，Read方法使指针指向下个字符，但是Peek还是指向原来那个字符</td>
</tr>
<tr>
<td>Read(char[] buffer, int index, int count)</td>
<td>从index处读取count个字符并赋值给buffer</td>
</tr>
<tr>
<td>ReadBlock(char[] buffer, int index, int count)</td>
<td>与Read的方法一致，效率更高但并非线程安全</td>
</tr>
<tr>
<td>ReadLine()</td>
<td>从当前流中读取一行字符并将数据作为字符串返回</td>
</tr>
<tr>
<td>ReadLineAsync()</td>
<td>从当前流中异步读取一行字符并将数据作为字符串返回</td>
</tr>
<tr>
<td>ReadToEnd()</td>
<td>从流的当前位置到末尾读取所有字符</td>
</tr>
</tbody>
</table>
</li>
<li>
<h3 id="读文件操作-2"><a class="markdownIt-Anchor" href="#读文件操作-2"></a> 读文件操作</h3>
</li>
</ul>
根据路径读取<pre class="highlight"><code class="C#"><span class="hljs-keyword">string</span> path = <span class="hljs-string">@"E:\khaki\Markdown\test.txt"</span>;
<span class="hljs-keyword">using</span> (StreamReader reader = <span class="hljs-keyword">new</span> StreamReader(path))
&#123;
    <span class="hljs-keyword">string</span> str = reader.ReadToEnd();
&#125;
</code></pre>
根据流读取<pre class="highlight"><code class="C#"><span class="hljs-keyword">string</span> path = <span class="hljs-string">@"E:\khaki\Markdown\test.txt"</span>;
<span class="hljs-keyword">using</span> (FileStream fs = <span class="hljs-keyword">new</span> FileStream(path, FileMode.Open, FileAccess.Read))
&#123;
    <span class="hljs-keyword">using</span> (StreamReader reader = <span class="hljs-keyword">new</span> StreamReader(fs))
    &#123;
        <span class="hljs-keyword">string</span> str = reader.ReadToEnd();
    &#125;
&#125;
</code></pre>
</li>
</ul>
<hr />
<ul>
<li>
<h2 id="其他流"><a class="markdownIt-Anchor" href="#其他流"></a> 其他流</h2>
<ul>
<li>
<h3 id="binaryreaderbinarywriter"><a class="markdownIt-Anchor" href="#binaryreaderbinarywriter"></a> BinaryReader/BinaryWriter</h3>
</li>
</ul>
<p>提供了对<code>字节流</code>的读写方法,读写方法和FileStream类似</p>
<pre class="highlight"><code class="C#"><span class="hljs-keyword">string</span> path = <span class="hljs-string">@"E:\khaki\Markdown\test.txt"</span>;
FileStream fs = <span class="hljs-keyword">new</span> FileStream(path, FileMode.Open, FileAccess.Read);
<span class="hljs-keyword">using</span> (BinaryReader binaryReader = <span class="hljs-keyword">new</span> BinaryReader(fs))
&#123;
    <span class="hljs-keyword">int</span> length = (<span class="hljs-keyword">int</span>)fs.Length;
    <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[length]
    <span class="hljs-keyword">int</span> r = binaryReader.Read(buffer, <span class="hljs-number">0</span>, length);
    <span class="hljs-keyword">string</span> info = Encoding.UTF8.GetString(buffer, <span class="hljs-number">0</span>, r);
&#125;
</code></pre>
<ul>
<li>
<h3 id="networkstream"><a class="markdownIt-Anchor" href="#networkstream"></a> NetworkStream</h3>
</li>
</ul>
<p>提供了对<code>Socket</code>中的<code>字节序列</code>进行操作,读写方法和FileStream类似</p>
<pre class="highlight"><code class="C#"><span class="hljs-keyword">using</span> (NetworkStream fs = <span class="hljs-keyword">new</span> NetworkStream(socket, FileAccess.Read))
&#123;
    <span class="hljs-keyword">using</span> (StreamReader reader = <span class="hljs-keyword">new</span> StreamReader(fs))
    &#123;
        <span class="hljs-keyword">string</span> str = reader.ReadToEnd();
    &#125;
&#125;
</code></pre>
<ul>
<li>
<h3 id="memorystream"><a class="markdownIt-Anchor" href="#memorystream"></a> MemoryStream</h3>
</li>
</ul>
<p>提供了对<code>保存在内存中</code>的<code>字节序列</code>进行操作,由于内存容量是自动增长的，因此适合在数据加密或对长度不定时使用</p>
<p>该流对Flush方法无效，应调用FlushFinalBlock将内部缓冲区的数据进行写入并清空缓冲区</p>
<ul>
<li>
<h3 id="cryptostream"><a class="markdownIt-Anchor" href="#cryptostream"></a> CryptoStream</h3>
</li>
</ul>
<p>对任意Stream进行加密或解密处理</p>
<ul>
<li>
<h3 id="bufferedstream"><a class="markdownIt-Anchor" href="#bufferedstream"></a> BufferedStream</h3>
</li>
</ul>
<p>将数据存放到内存中的一个字节块内，避免频繁从磁盘中读取数据</p>
</li>
</ul>

    </div>
    
    <div class="footer">
    <hr>
        <font> ©2021 </font>
        <a target="_blank" rel="noopener" href="https://github.com/Gatongone/" style="color: rgb(214, 207, 218);">Gatongone</a>
        some copyrights reserved
        <div style="float: right; margin-right: -200px;">
              Mar 14th  2021,  5:32:04  |
            <font>Powered by</font>
            <a target="_blank" rel="noopener" href="https://hexo.io/"  style="color: rgb(214, 207, 218);">Hexo</a>
            framework
        </div>
    </div>
</body>
    



</div>



<script>
     var bar=document.getElementById("top_btn")
     var showtime=0;
     var hidetime=0;
     window.addEventListener("pageshow",function(){
         let scrollTop = window.pageYOffset ||document.documentElement.scrollTop|| document.body.scrollTop || 0;
        if(scrollTop ==0)
        {
            bar.style.display = 'none';
        }
        else
        {
            bar.style.display = 'block';
        }
        window.addEventListener("scroll",function(){
            bar.style.display = 'block';
            scrollTop = window.pageYOffset ||document.documentElement.scrollTop|| document.body.scrollTop || 0;
            if(scrollTop != 0)
            {
                if(hidetime==0)
                {
                    bar.classList.toggle("top_btn_show");
                    hidetime++;
                }
                showtime=0;
            }  
            else
            {
                if(showtime==0 && hidetime!=0)
                {
                    bar.classList.toggle("top_btn_show");
                    showtime++;
                    hidetime=0;
                }
            }
        }) 
     })
     
    var timer = null;
    bar.onclick = function()
    {
        cancelAnimationFrame(timer);
        timer = requestAnimationFrame(function fn()
        {
            var top = document.body.scrollTop || document.documentElement.scrollTop;
            if(top > 0)
            {
                document.body.scrollTop = document.documentElement.scrollTop = top - 80;
                timer = requestAnimationFrame(fn);
            }
            else
            {
                cancelAnimationFrame(timer);
            } 
        });
    }
         
</script>


<script src="//cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.js"></script>

<script src="/blog/js/showpost.js"></script>

<script>
    hljs.initHighlightingOnLoad();
</script>


</body>                                             <!--  加载主体  -->

        </div>                                                                 
        
<script src="/blog/js/searchbar.js"></script>
<script src="/blog/js/hidebar.js"></script>
              <!--    加载JS  -->                                                          
    </body>

</html>