<!DOCTYPE html>
<html lang="ch">

<head>
    <meta charset="UTF-8">
    <meta name="Author" content="Gatongone">
    <meta name="Description" content="Gatongone's Blog">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body
        {
            background-color: rgb(20, 20, 34);
            -ms-overflow-style: none; /* IE 10+ */
            scrollbar-width: none; /* Firefox */
            
        }
        ::-webkit-scrollbar
        {
        display: none; /* Chrome Safari */
        }
    </style>
<meta name="generator" content="Hexo 5.3.0"></head>

    <body>
        
<link rel="stylesheet" href="/blog/css/leftsidebar.css">


<script src="/blog/js/hidebar.js"></script>

<div class="leftpanel_out" id="leftpanel_out">
    <div class="block1"></div>

    <div class="profile_background" id="profile_background">
        <a href="https://gatongone.github.io" title="Navigation" target="_self">
            <img class="profile" src="/blog/images/profile.jpg" />
        </a>
    </div>

    <img class="block2" src="/blog/images/block.png"/>

    <div class="buttons">
        <a>
           
        </a>
        <a target="_blank" rel="noopener" href="https://space.bilibili.com/26209665" title="bilibili">
            <img class="shadowfilter bilibili" src="/blog/images/icon/bilibili_btn.png"/>
        </a>
         <a>
           
        </a>
        <a target="_blank" rel="noopener" href="https://gatongone.lofter.com/" title="lofter">
            <img class="shadowfilter lofter" src="/blog/images/icon/lofter_btn.png"/>
        </a>
         <a>
           
        </a>
         <a target="_blank" rel="noopener" href="https://github.com/Gatongone/" title="github">
            <img class="shadowfilter github" src="/blog/images/icon/github_btn.png"/>
        </a>
         <a>
           
        </a>
        <a target="_blank" rel="noopener" href="https://blog.csdn.net/Gatongone" title="CSDN">
            <img class="shadowfilter csdn" src="/blog/images/icon/csdn_btn.png"/>
        </a>
    </div>
    <div class="block3"></div>
</div>
<script>
    var obj=document.getElementById('leftpanel_out');
    MoveBar(obj,"leftpanel_in",1150)
</script>                       <!-- 加载侧边栏 -->

        <div class='body-wrapper' id="body-wrapper">

            <head>
    <title>
        
    </title>
</head>
<body>
    
<link rel="stylesheet" href="/blog/css/topbar.css">


<script src="/blog/js/searchbar.js"></script>
<script src="/blog/js/hidebar.js"></script>
  
<div class="topbar" id="topbar">
    <font class="title_top" id="title_top">Gatongone's blog</font>
    <div id="topblock">
        <div id="text">
            <font id='about' class="buttonfont">▼About</font>
            <font id="plan" class="buttonfont">Planing</font>
            <font id="RSS" class="buttonfont">RSS</font>
        </div>
        
        <input id="search_input" class="st-default-search-input " type="text" placeholder="search with title" value="" onkeydown=" if(event.which==13)''"/>
        
        <button><img src="/blog/images/icon/search.png" style="height: 16px; width: 18px; margin-top: 2px;"></button>
    </div>
</div>

<!-- swiftype search -->


<script>
    var obj2=document.getElementById('title_top');
    var obj3=document.getElementById("text");
    //HideBar(obj2,1270);
    MoveBar(obj2,"title_top2",1270);
    //HideBar(obj3,650);
    MoveBar(obj3,"text2",800);

    if(sessionStorage.getItem("isReload")){
    }else{
    sessionStorage.setItem("isReload", true)
    }
</script>
    
<link rel="stylesheet" href="/blog/css/mainbody.css">


<!-- 回到首页 -->

    <a href="/blog/">
    <button class="home_btn">
        <img src="/blog/images/icon/home.png">
    </button>
    </a>


<!-- 回到顶部 -->
<div id="top">
    <button class="top_btn" id="top_btn">
        <img src="/blog/images/icon/top.png">
    </button>
</div>
<!-- 主体 -->

<div class="mainbody" id="mainbody">
<!-- 加载post_entry -->
    <div class="entry">
    

    
<!--    加载post    -->    

    
        <head>
    <title>unity脚本生命周期</title>
</head>
<body>

    
<link rel="stylesheet" href="/blog/css/post.css">

    
<link rel="stylesheet" href="/blog/css/hightlight.css">




    <div class="page_title" id="page_title">
        unity脚本生命周期
    </div>
    <hr>
    <div class="page_content">
        
        
        <blockquote>
<p>摘自unity官方手册：<a target="_blank" rel="noopener" href="https://docs.unity3d.com/2019.3/Documentation/Manual/ExecutionOrder.html">https://docs.unity3d.com/2019.3/Documentation/Manual/ExecutionOrder.html</a></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/Gatongone/ImageContainer/main/Others/unity%20Mono%E8%84%9A%E6%9C%AC%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="alt" style="max-width:100%;" ></p>
<hr>
<ul>
<li><h2 id="场景第一次加载"><a href="#场景第一次加载" class="headerlink" title="场景第一次加载"></a>场景第一次加载</h2><p>当 场景 开始时会调用这些函数（场景中每个对象执行一次）</p>
<ul>
<li><h3 id="Awake："><a href="#Awake：" class="headerlink" title="Awake："></a>Awake：</h3>   此函数始终会在任何 Start 函数之前以及预制件（prefab）之后实例化（如果 GameObject 在启动期间处于非活动状态，则在激活之前不会调用 Awake。）</li>
<li><h3 id="OnEnable："><a href="#OnEnable：" class="headerlink" title="OnEnable："></a>OnEnable：</h3>  （仅在 Object 处于活动状态时调用）在启用对象后立即调用此函数。在创建 MonoBehaviour 实例时会发生这种情况，例如加载关卡时或者 游戏 中的脚本组件实例化。</li>
<li><h3 id="OnLevelWasLoaded"><a href="#OnLevelWasLoaded" class="headerlink" title="OnLevelWasLoaded"></a>OnLevelWasLoaded</h3>   执行此函数以通知游戏已加载新关卡。</li>
<li><h3 id="请注意，对于添加到场景中的对象，所有-脚本-的-Awake-和-OnEnable-函数中的任何一个，在调用Start，Update等之前调用。当然，在游戏过程中实例化对象时，不能强制执行此操作。"><a href="#请注意，对于添加到场景中的对象，所有-脚本-的-Awake-和-OnEnable-函数中的任何一个，在调用Start，Update等之前调用。当然，在游戏过程中实例化对象时，不能强制执行此操作。" class="headerlink" title="请注意，对于添加到场景中的对象，所有 脚本 的 Awake 和 OnEnable 函数中的任何一个，在调用Start，Update等之前调用。当然，在游戏过程中实例化对象时，不能强制执行此操作。"></a>请注意，对于添加到场景中的对象，所有 脚本 的 Awake 和 OnEnable 函数中的任何一个，在调用Start，Update等之前调用。当然，在游戏过程中实例化对象时，不能强制执行此操作。</h3></li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><h2 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h2><ul>
<li><h3 id="Reset："><a href="#Reset：" class="headerlink" title="Reset："></a>Reset：</h3>   调用 Reset 以在脚本首次附加到对象时以及使用重置命令时初始化脚本的属性。</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><h2 id="在第一帧更新之前"><a href="#在第一帧更新之前" class="headerlink" title="在第一帧更新之前"></a>在第一帧更新之前</h2><ul>
<li><h3 id="Start："><a href="#Start：" class="headerlink" title="Start："></a>Start：</h3><p>   仅在启用脚本实例时才在第一帧更新之前调用 Start。</p>
<p>   对于添加到场景中的对象，将在所有脚本上调用 Start 函数，然后为其中任何脚本调用 Update 等。当然，在游戏过程中实例化对象时，不能强制执行此操作。</p>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><h2 id="在帧之间"><a href="#在帧之间" class="headerlink" title="在帧之间"></a>在帧之间</h2><ul>
<li><h3 id="OnApplicationPause："><a href="#OnApplicationPause：" class="headerlink" title="OnApplicationPause："></a>OnApplicationPause：</h3>   在检测到暂停的帧的末尾调用，有效地在正常帧更新之间调用。调用 OnApplicationPause 后，将发出一个额外的帧，以允许游戏显示指示暂停状态的图形。</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><h2 id="更新顺序"><a href="#更新顺序" class="headerlink" title="更新顺序"></a>更新顺序</h2><p>  当你跟踪游戏逻辑和交互、动画、相机和位置等，您可以使用一些不同的事件。常见模式是在 Update 函数中执行大多数任务，但也可以使用其他函数。</p>
<ul>
<li><h3 id="FixedUpdate："><a href="#FixedUpdate：" class="headerlink" title="FixedUpdate："></a>FixedUpdate：</h3>   通常比 Update 更频繁地调用 FixedUpdate。如果帧速率低，则可以每帧调用多次，如果帧速率高，则可以不在帧之间调用。所有物理计算和更新在 FixedUpdate 之后立即发生。在 FixedUpdate 中应用移动计算时，您不需要将您的值乘以 Time.deltaTime。这是因为在可靠的定时器上调用 FixedUpdate，与帧速率无关。</li>
<li><h3 id="Update："><a href="#Update：" class="headerlink" title="Update："></a>Update：</h3>   每帧调用一次 Update。它是帧更新的主要函数。</li>
<li><h3 id="LateUpdate："><a href="#LateUpdate：" class="headerlink" title="LateUpdate："></a>LateUpdate：</h3>   在 Update 完成后，每帧调用一次 LateUpdate。在 LateUpdate 开始时，将在 Update 中执行的任何计算都已完成。LateUpdate 的一个常见用途是使用以下第三人称相机。如果您使角色移动并在 Update 内转向，您可以在 LateUpdate 中执行所有相机移动和旋转计算。这将确保角色在摄像机跟踪其位置之前完全移动。</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><h2 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h2><ul>
<li><h3 id="OnPreCull："><a href="#OnPreCull：" class="headerlink" title="OnPreCull："></a>OnPreCull：</h3><p>   在相机剔除场景之前调用。剔除决定哪些对象对相机可见。在剔除之前调用 OnPreCull。</p>
</li>
<li><h3 id="OnBecameVisible-OnBecameInvisible："><a href="#OnBecameVisible-OnBecameInvisible：" class="headerlink" title="OnBecameVisible / OnBecameInvisible："></a>OnBecameVisible / OnBecameInvisible：</h3><p>   当对象对任何摄像机可见 / 不可见时调用。</p>
</li>
<li><h3 id="OnWillRenderObject："><a href="#OnWillRenderObject：" class="headerlink" title="OnWillRenderObject："></a>OnWillRenderObject：</h3><p>   如果对象可见，则为每个摄像机调用一次。</p>
</li>
<li><h3 id="OnPreRender："><a href="#OnPreRender：" class="headerlink" title="OnPreRender："></a>OnPreRender：</h3><p>   在相机开始 渲染 之前调用场景。</p>
</li>
<li><h3 id="OnRenderObject："><a href="#OnRenderObject：" class="headerlink" title="OnRenderObject："></a>OnRenderObject：</h3><p>   在完成所有常规场景渲染后调用。您可以使用 GL 类或 Graphics.DrawMeshNow 来绘制自定义几何体。</p>
</li>
<li><h3 id="OnPostRender："><a href="#OnPostRender：" class="headerlink" title="OnPostRender："></a>OnPostRender：</h3><p>   在相机完成场景渲染后调用。</p>
</li>
<li><h3 id="OnRenderImage："><a href="#OnRenderImage：" class="headerlink" title="OnRenderImage："></a>OnRenderImage：</h3><p>   在场景渲染完成后调用以允许对图像进行后处理，请参阅 后处理效果。</p>
</li>
<li><h3 id="OnGUI："><a href="#OnGUI：" class="headerlink" title="OnGUI："></a>OnGUI：</h3><p>   响应GUI事件，每帧调用多次。首先处理 Layout 和 Repaint 事件，然后为每个输入事件处理 Layout 和 keyboard / mouse 事件。</p>
</li>
<li><h3 id="OnDrawGizmos："><a href="#OnDrawGizmos：" class="headerlink" title="OnDrawGizmos："></a>OnDrawGizmos：</h3><p>   用于绘制 Gizmos 在 场景视图 中用于可视化目的。</p>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><ul>
<li><h3 id="Update：-1"><a href="#Update：-1" class="headerlink" title="Update："></a>Update：</h3><p>   函数返回后运行正常的协同程序更新。协程是一个可以暂停执行（yield）直到给定的 YieldInstruction 完成的函数。协程的不同用途：</p>
</li>
<li><h3 id="yield："><a href="#yield：" class="headerlink" title="yield："></a>yield：</h3><p>   在下一帧调用所有 Update 函数后，协程将继续运行。</p>
</li>
<li><h3 id="yield-WaitForSeconds："><a href="#yield-WaitForSeconds：" class="headerlink" title="yield WaitForSeconds："></a>yield WaitForSeconds：</h3><p>   在为帧调用所有 Update 函数后，在指定的时间延迟后继续。</p>
</li>
<li><h3 id="yield-WaitForFixedUpdate："><a href="#yield-WaitForFixedUpdate：" class="headerlink" title="yield WaitForFixedUpdate："></a>yield WaitForFixedUpdate：</h3><p>   在所有脚本上调用所有 FixedUpdate 后继续。</p>
</li>
<li><h3 id="yield-WWW："><a href="#yield-WWW：" class="headerlink" title="yield WWW："></a>yield WWW：</h3><p>   在 WWW 下载完成后继续。</p>
</li>
<li><h3 id="yield-StartCoroutine："><a href="#yield-StartCoroutine：" class="headerlink" title="yield StartCoroutine："></a>yield StartCoroutine：</h3><p>   链接协程，并将等待 MyFunc 协程首先完成。</p>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><h2 id="当对象被销毁"><a href="#当对象被销毁" class="headerlink" title="当对象被销毁"></a>当对象被销毁</h2><ul>
<li><h3 id="OnDestroy："><a href="#OnDestroy：" class="headerlink" title="OnDestroy："></a>OnDestroy：</h3>   在对象存在的最后一帧的所有帧更新之后调用此函数（该对象可能会在响应 Object.Destroy 或场景关闭时被销毁）。</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><h2 id="退出时"><a href="#退出时" class="headerlink" title="退出时"></a>退出时</h2><p>  在场景中的所有活动对象上调用这些函数：</p>
<ul>
<li><h3 id="OnApplicationQuit："><a href="#OnApplicationQuit：" class="headerlink" title="OnApplicationQuit："></a>OnApplicationQuit：</h3><p>   在退出应用程序之前，在所有游戏对象上调用此函数。在编辑器中，当用户停止播放模式时调用它。</p>
</li>
<li><h3 id="OnDisable："><a href="#OnDisable：" class="headerlink" title="OnDisable："></a>OnDisable：</h3><p>   当行为被禁用或处于非活动状态时，将调用此函数。</p>
</li>
</ul>
</li>
</ul>

    </div>
    
    <div class="footer">
    <hr>
        <font> ©2021 </font>
        <a target="_blank" rel="noopener" href="https://github.com/Gatongone/" style="color: rgb(214, 207, 218);">Gatongone</a>
        some copyrights reserved
        <div style="float: right; margin-right: -200px;">
              Feb 15th  2021,  3:12:46  |
            <font>Powered by</font>
            <a target="_blank" rel="noopener" href="https://hexo.io/"  style="color: rgb(214, 207, 218);">Hexo</a>
            framework
        </div>
    </div>
</body>
    



</div>



<script>
     var bar=document.getElementById("top_btn")
     var showtime=0;
     var hidetime=0;
     window.addEventListener("pageshow",function(){
         let scrollTop = window.pageYOffset ||document.documentElement.scrollTop|| document.body.scrollTop || 0;
        if(scrollTop ==0)
        {
            bar.style.display = 'none';
        }
        else
        {
            bar.style.display = 'block';
        }
        window.addEventListener("scroll",function(){
            bar.style.display = 'block';
            scrollTop = window.pageYOffset ||document.documentElement.scrollTop|| document.body.scrollTop || 0;
            if(scrollTop != 0)
            {
                if(hidetime==0)
                {
                    bar.classList.toggle("top_btn_show");
                    hidetime++;
                }
                showtime=0;
            }  
            else
            {
                if(showtime==0 && hidetime!=0)
                {
                    bar.classList.toggle("top_btn_show");
                    showtime++;
                    hidetime=0;
                }
            }
        }) 
     })
     
    var timer = null;
    bar.onclick = function()
    {
        cancelAnimationFrame(timer);
        timer = requestAnimationFrame(function fn()
        {
            var top = document.body.scrollTop || document.documentElement.scrollTop;
            if(top > 0)
            {
                document.body.scrollTop = document.documentElement.scrollTop = top - 80;
                timer = requestAnimationFrame(fn);
            }
            else
            {
                cancelAnimationFrame(timer);
            } 
        });
    }
         
</script>

<script src="//cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>


</body>                                             <!--  加载主体  -->

        </div>                                                                 
        
<script src="/blog/js/searchbar.js"></script>
<script src="/blog/js/hidebar.js"></script>
              <!--    加载JS  -->                                                          
    </body>

</html>