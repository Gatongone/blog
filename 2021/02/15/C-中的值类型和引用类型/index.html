<!DOCTYPE html>
<html lang="ch">

<head>
    <meta charset="UTF-8">
    <meta name="Author" content="Gatongone">
    <meta name="Description" content="Gatongone's Blog">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/x-icon"  href="/images/NeonGame_L.ico">
    <link rel="icon" type="image/x-icon"  href="/images/NeonGame_M.ico">
    <link rel="icon" type="image/x-icon"  href="/images/NeonGame_S.ico">
    <style>
        body
        {
            background-color: rgb(20, 20, 34);
            -ms-overflow-style: none; /* IE 10+ */
            scrollbar-width: none; /* Firefox */
            
        }
        ::-webkit-scrollbar
        {
            display: none; /* Chrome Safari */
        }
    </style>
<meta name="generator" content="Hexo 5.3.0"></head>

    <body>
        
<link rel="stylesheet" href="/blog/css/leftsidebar.css">


<script src="/blog/js/hidebar.js"></script>

<div class="leftpanel_out" id="leftpanel_out">
    <div class="block1"></div>

    <div class="profile_background" id="profile_background">
        <a href="https://www.gatongone.site" title="Navigation" target="_self">
            <img class="profile" src="/blog/images/profile.jpg" />
        </a>
    </div>

    <img class="block2" src="/blog/images/block.png"/>

    <div class="buttons">
        <a>
           
        </a>
        <a target="_blank" rel="noopener" href="https://space.bilibili.com/26209665" title="bilibili">
            <img class="shadowfilter bilibili" src="/blog/images/icon/bilibili_btn.png"/>
        </a>
         <a>
           
        </a>
        <a target="_blank" rel="noopener" href="https://gatongone.lofter.com/" title="lofter">
            <img class="shadowfilter lofter" src="/blog/images/icon/lofter_btn.png"/>
        </a>
         <a>
           
        </a>
         <a target="_blank" rel="noopener" href="https://github.com/Gatongone/" title="github">
            <img class="shadowfilter github" src="/blog/images/icon/github_btn.png"/>
        </a>
         <a>
           
        </a>
        <a target="_blank" rel="noopener" href="https://blog.csdn.net/Gatongone" title="CSDN">
            <img class="shadowfilter csdn" src="/blog/images/icon/csdn_btn.png"/>
        </a>
    </div>
    <div class="block3"></div>
</div>
<script>
    var obj=document.getElementById('leftpanel_out');
    MoveBar(obj,"leftpanel_in",1150)
</script>                       <!-- 加载侧边栏 -->

        <div class='body-wrapper' id="body-wrapper">

            <head>
 <link rel="icon" type="image/x-icon"  href="/images/NeonGame_L.ico">
 <link rel="icon" type="image/x-icon"  href="/images/NeonGame_M.ico">
 <link rel="icon" type="image/x-icon"  href="/images/NeonGame_S.ico">
 
</head>
<body>
    
<link rel="stylesheet" href="/blog/css/topbar.css">


<script src="/blog/js/searchbar.js"></script>
<script src="/blog/js/hidebar.js"></script>
  
<div class="topbar" id="topbar">
    <font class="title_top" id="title_top">Gatongone's blog</font>
    <div id="topblock">
        <div id="text">
            <font id='about' class="buttonfont">▼About</font>
            <font id="plan" class="buttonfont">Planing</font>
            <font id="RSS" class="buttonfont">RSS</font>
        </div>
        
        <input id="search_input"  type="text" placeholder="search with title" value="" onkeydown=" if(event.which==13)''">
        <button><img src="/blog/images/icon/search.png" style="height: 16px; width: 18px; margin-top: 2px;"></button>
    </div>
</div>

<!-- swiftype search -->

<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');
  
  _st('install','7xj-dxBhzvJx1yWsVMJU','2.0.0');
</script>
    </script>


<script>
    var obj2=document.getElementById('title_top');
    var obj3=document.getElementById("text");
    //HideBar(obj2,1270);
    MoveBar(obj2,"title_top2",1270);
    //HideBar(obj3,650);
    MoveBar(obj3,"text2",800);

    if(sessionStorage.getItem("isReload")){
    }else{
    sessionStorage.setItem("isReload", true)
    }
</script>
    
<link rel="stylesheet" href="/blog/css/mainbody.css">


<!-- 回到首页 -->

    <a href="/blog/">
    <button class="home_btn">
        <img src="/blog/images/icon/home.png">
    </button>
    </a>


<!-- 回到顶部 -->
<div id="top">
    <button class="top_btn" id="top_btn">
        <img src="/blog/images/icon/top.png">
    </button>
</div>
<!-- 主体 -->

<div class="mainbody" id="mainbody">
<!-- 加载post_entry -->
    <div class="entry">
    

    
<!--    加载post    -->    

    
        <head>
    <title>C#中的值类型和引用类型</title>
    <link rel="icon" type="image/x-icon"  href="/images/NeonGame_L.ico">
    <link rel="icon" type="image/x-icon"  href="/images/NeonGame_M.ico">
    <link rel="icon" type="image/x-icon"  href="/images/NeonGame_S.ico">
</head>
<body>

    
<link rel="stylesheet" href="/blog/css/post.css">

    
<link rel="stylesheet" href="/blog/css/hightlight.css">


    
<link rel="stylesheet" href="/blog/css/rightbar.css">


<script src="/blog/js/hidebar.js"></script>

<div id="right_bar">

        

        
            <div id="post_index" class="post_index">
                <span> Post Index </span>
                <div>
                    <div id="clear"></div>
                    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-text">常见的值类型和引用类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%BC%E7%B1%BB%E5%9E%8B%EF%BC%9A"><span class="toc-text">值类型：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%EF%BC%9A"><span class="toc-text">引用类型：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%8A%E5%8C%BA%E5%88%AB"><span class="toc-text">值类型和引用类型的在内存上区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2%EF%BC%88%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1%EF%BC%89"><span class="toc-text">值类型和引用类型的转换（装箱与拆箱）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A3%85%E7%AE%B1"><span class="toc-text">装箱</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%86%E7%AE%B1"><span class="toc-text">拆箱</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E5%8F%A5%E5%9D%97%E4%B8%8EGC"><span class="toc-text">语句块与GC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E5%8F%A5%E5%9D%97"><span class="toc-text">语句块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GC"><span class="toc-text">GC</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E7%B1%BB"><span class="toc-text">结构体和类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E5%A4%9A%E7%9A%84%E5%8C%BA%E5%88%AB%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-text">更多的区别总结：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%80%BC%E7%B1%BB%E5%9E%8B%E6%95%B0%E7%BB%84%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%95%B0%E7%BB%84"><span class="toc-text">值类型数组和引用类型数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E7%9A%84%E5%BC%95%E7%94%A8%EF%BC%9Astring%E9%A9%BB%E7%95%99%E6%B1%A0"><span class="toc-text">特殊的引用：string驻留池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#is%E5%92%8Cas-%E5%AF%B9%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%88%A4%E6%96%AD%E5%92%8C%E8%BD%AC%E6%8D%A2"><span class="toc-text">is和as:对类型的判断和转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#as"><span class="toc-text">as</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#is"><span class="toc-text">is</span></a></li></ol></li></ol>
                </div>
                
             </div>
        

</div>
<script>
    var bar=document.getElementById("right_bar");
    MoveBar(bar,"right_bar_hide",1120)
</script>

    <div class="page_title" id="page_title">
        C#中的值类型和引用类型
    </div>
    <hr>
    <div class="page_content">
        
        
        <h2 id="常见的值类型和引用类型"><a href="#常见的值类型和引用类型" class="headerlink" title="常见的值类型和引用类型"></a>常见的值类型和引用类型</h2><ul>
<li><h3 id="值类型："><a href="#值类型：" class="headerlink" title="值类型："></a>值类型：</h3><ul>
<li>无符号类型：byte,ushort,uint,ulong</li>
<li>有符号类型：sbyte,short,int,long</li>
<li>浮点类型：float,double,decimal</li>
<li>布尔类型：bool</li>
<li>字符型：char</li>
<li>枚举：enum</li>
<li>结构体：struct</li>
<li>指针：int*,float*,……</li>
<li>可空类型：int?,float?,……</li>
</ul>
</li>
<li><h3 id="引用类型："><a href="#引用类型：" class="headerlink" title="引用类型："></a>引用类型：</h3><ul>
<li>类：class</li>
<li>接口：interface</li>
<li>数组：xxx[] </li>
<li>委托：delegate,Func&lt;&gt;,Action&lt;&gt;</li>
<li>其他：string,DateTime……</li>
</ul>
</li>
</ul>
</br>

<hr>
<h2 id="值类型和引用类型的在内存上区别"><a href="#值类型和引用类型的在内存上区别" class="headerlink" title="值类型和引用类型的在内存上区别"></a>值类型和引用类型的在内存上区别</h2><ul>
<li><p>值类型实例一般保存在线程栈中，因此不受GC的控制，缓解了托管堆中的压力。值类型的实例就是自己本身。值类型创建时，runtime会为其分配一个内存空间到栈上。</p>
</li>
<li><p>引用类型一定分配在托管堆中，在C#中受到GC的控制，以此过多的引用类型会导致GC的次数，以致于性能下降。引用类型被创建（new）时，runtime会创建两个内存空间，一个分配在栈上用于保存实例，一个分配在堆中用于保存指向实例的内存地址。</p>
</li>
<li><p>ps：值类型不一定都是保存在线程栈中的<br>如果值类型是方法内部创建的，则被保存在线程栈上；<br>如果值类型是引用类型的成员变量，则跟随引用类型被存储在托管堆中。</p>
</li>
</ul>
</br>

<hr>
<h2 id="值类型和引用类型的转换（装箱与拆箱）"><a href="#值类型和引用类型的转换（装箱与拆箱）" class="headerlink" title="值类型和引用类型的转换（装箱与拆箱）"></a>值类型和引用类型的转换（装箱与拆箱）</h2><ul>
<li><h3 id="装箱"><a href="#装箱" class="headerlink" title="装箱"></a>装箱</h3>  装箱就是将值类型转换成引用类型，过程为：<ol>
<li>在托管堆中分配内存，容量为：实例字段 + 类型指针 + 同步块索引</li>
<li>Copy字段到刚分配的堆内存中</li>
<li>返回堆中新分配对象的地址，该地址是指向值对象的引用<pre><code class="C#">int num = 5;
object obj = num;//装箱
</code></pre>
<img src="%E8%A3%85%E7%AE%B1.jpg" alt="img" style="max-width:100%;" ></li>
</ol>
</li>
</ul>
</br>
</br>   

<ul>
<li><h3 id="拆箱"><a href="#拆箱" class="headerlink" title="拆箱"></a>拆箱</h3><p>  拆箱就是将已装箱的值类型（装箱之后就是引用类型了）转换成值类型，过程为：</p>
<ol>
<li>获取托管堆中属于值类型那部分字段的地址，</li>
<li>将引用对象中的值Copy到位于线程堆栈上的值类型实例中。 <pre><code class="C#">object obj = 5;
int i = (int)obj;
</code></pre>
<img src="%E6%8B%86%E7%AE%B1.jpg" alt="img" style="max-width:100%;" ></li>
</ol>
</li>
</ul>
</br>

<hr>
<h2 id="语句块与GC"><a href="#语句块与GC" class="headerlink" title="语句块与GC"></a>语句块与GC</h2><ul>
<li><h3 id="语句块"><a href="#语句块" class="headerlink" title="语句块"></a>语句块</h3><p>   一般可以把C#中语句块分为四个层级：</p>
<ul>
<li><p>底层：</p>
<ul>
<li>一层：条件分支、循环语句块</li>
<li>二层：函数语句块</li>
</ul>
</li>
<li><p>中层：</p>
<ul>
<li>三层：类、接口、结构体语句块块</li>
</ul>
</li>
<li><p>顶层:</p>
<ul>
<li>四层：using语句</li>
</ul>
</br> 

<p>变量可以声明在底层和中层语句块中，逻辑代码只能写在底层语句块中。</p>
<p>变量若写在底层语句块中，则是临时变量，若写在中层语句块中，则是全局变量。</p>
</br>
</li>
</ul>
</li>
<li><h3 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h3><p>  在C#中，对于临时变量（没有在外部被记录的变量）：</p>
<ul>
<li><h4 id="值类型：-1"><a href="#值类型：-1" class="headerlink" title="值类型："></a>值类型：</h4><p>  每当变量所在语句块结束后，存储在线程栈中的变量将会以先进后出的顺序被变成垃圾回收掉；</p>
</li>
<li><h4 id="引用类型：-1"><a href="#引用类型：-1" class="headerlink" title="引用类型："></a>引用类型：</h4><p>  若指向对象的地址上的内容被回收后,托管堆的内容变成垃圾仍未被回收，需要等到下一次GC或手动调用GC.Collect()；进行回收。</p>
<p>因此，若希望变量不会被系统回收，应该尽量将变量声明在更高级的语句块中。</p>
</li>
</ul>
</li>
</ul>
</br>

<hr>
<h2 id="结构体和类"><a href="#结构体和类" class="headerlink" title="结构体和类"></a>结构体和类</h2><pre><code class="C#"> public struct StructTest
 &#123;
     float num1;
     int num2;;
     Object obj;
 &#125;
 
 public class ClassTest
 &#123;
     float num1;
     int num2;
     Object obj;
 &#125;
</code></pre>
<p>   对以上结构体和类分别声明：</p>
<pre><code class="C#"> static void Main(string[] args)
 &#123;
     //结构体
     StructTest st = new StructTest();

     //类
     ClassTest ct = new ClassTest();
 &#125;    
</code></pre>
<p>   它们在堆栈中的内存分配情况分别为：</p>
<ul>
<li><p>Struct结构体：<br>   在栈中，为st分配了一个空间，分别用于存放num1的实例、num2的实例、obj的地址；</p>
<p>   在声明结构体后（new），在堆中开辟了一个空间用于存放obj的引用，而此时栈中的obj的值为指向堆中新内存的地址;</p>
<p>   总结：在结构体中，栈存值实例和引用地址，堆存引用实例</p>
</br>
</li>
<li><p>Class类：<br>   在栈中，为ct分配了空间，用于存储堆中的地址；在堆中分配了空间，分别用于存放num1的实例、num2的实例、obj的地址；</p>
<p>   声明类后（new），在堆中为obj额外分配了新的空间，用于存储obj的实例。</p>
<p>   总结: 在类中，栈存类的引用地址，堆存值实例、引用实例和引用地址</p>
</br>

<p><img src="struct_and_class.jpg" alt="img" style="max-width:100%;" ></p>
</li>
</ul>
</br>

<h3 id="更多的区别总结："><a href="#更多的区别总结：" class="headerlink" title="更多的区别总结："></a>更多的区别总结：</h3><table>
<thead>
<tr>
<th>\</th>
<th>Struct结构体</th>
<th>Class类</th>
</tr>
</thead>
<tbody><tr>
<td>数据类型</td>
<td>值类型</td>
<td>引用类型</td>
</tr>
<tr>
<td>储存的内存空间位置</td>
<td>线程栈</td>
<td>托管堆</td>
</tr>
<tr>
<td>特性</td>
<td>不具有继承和多态的特性（但是可以继承接口），因此不能被protected保护访问符修饰</td>
<td>继承、封装、多态</td>
</tr>
<tr>
<td>构造函数</td>
<td>必须初始化所有成员变量</td>
<td>随意</td>
</tr>
<tr>
<td>显示的无参构造函数</td>
<td>不能声明（因为默认自带了一个）</td>
<td>可以声明（将隐藏隐式的无参构造函数）</td>
</tr>
<tr>
<td>析构函数</td>
<td>不能声明</td>
<td>可以声明</td>
</tr>
<tr>
<td>static修饰符</td>
<td>不存在静态的结构体</td>
<td>可以被修饰</td>
</tr>
<tr>
<td>内部声明自身</td>
<td>不能在结构体内部声明自身结构体</td>
<td>可以在内部声明自身类</td>
</tr>
</tbody></table>
</br>

<hr>
<h2 id="值类型数组和引用类型数组"><a href="#值类型数组和引用类型数组" class="headerlink" title="值类型数组和引用类型数组"></a>值类型数组和引用类型数组</h2><pre><code class="C#"> int[] array = new int[]&#123;1,2,3,4,5,6&#125;;
 object[] objlist = new object[]&#123;1,2,3,4,5,6&#125;;
</code></pre>
<p>   对于数组的声明，其实和类与结构体的区别类似：</p>
<ul>
<li><p>值类型数组：栈中存数组引用的地址，堆中存数组实例；</p>
</li>
<li><p>引用类型数组：栈中存数组引用的地址，堆中存数组的实例和引用，其中每个引用分别指向各自的实例。</p>
</br>

<p><img src="array.jpg" alt="alt" style="max-width:100%;" ></p>
</li>
</ul>
</br>

<hr>
<h2 id="特殊的引用：string驻留池"><a href="#特殊的引用：string驻留池" class="headerlink" title="特殊的引用：string驻留池"></a>特殊的引用：string驻留池</h2><p>   string作为一种特殊的引用类型却往往表现出值类型的行为，最特别的是它的不变性，当我们同时new两个相同字符串的string时，检查地址会发现指向的是同一个实例对象。</p>
<pre><code>```C#
 string a = &quot;ssss&quot;;
 string b = &quot;ssss&quot;;
 //a和b均指向同一地址
```
</code></pre>
<p>   这是由于<code>CLR</code>在初始化时维护了一张<code>哈希表（驻留池）</code>，其中键为字符串，值为指向托管堆中字符串的引用。<code>JIT</code>在编译时，会检查驻留池中的字符串，如果没有找到，则在托管堆中构造一个指向该字符串的对象引用，并将该字符串和引用添加至散列表中。</p>
<pre><code>```C#
 string a = &quot;abc&quot;;
 string b = a;
 a = &quot;abcdef&quot;
 Console.WriteLine(&quot;b=&quot;+b);
 //输出：b=abc
```
</code></pre>
<p>   在上面的程序中之所以会表现出值类型的行为，是因为<code>string b = a;</code>并不是b指向了a的引用，而是指向了驻留池中的字符串”abc”。</p>
</br>

<hr>
<h2 id="is和as-对类型的判断和转换"><a href="#is和as-对类型的判断和转换" class="headerlink" title="is和as:对类型的判断和转换"></a>is和as:对类型的判断和转换</h2><ul>
<li><h3 id="as"><a href="#as" class="headerlink" title="as"></a>as</h3><pre><code class="C#">    Object obj = new Object();
    Type type = obj as Type;//用强制转换的方法则需要try-catch保护，因为这是线程不安全的
</code></pre>
<p>  as操作符对于 <strong>目标类型属于目标类型或者目标类型的派生类型</strong> 才能转换成功，否则返回null；</p>
<p>  注意as操作符不能对值类型进行转换。</p>
</li>
<li><h3 id="is"><a href="#is" class="headerlink" title="is"></a>is</h3><pre><code class="C#">    Object obj = 1;

    if (obj is int)
    &#123;
        int value = (int) obj;
    &#125;

    //或者
    int value = obj is int ? (int)obj : default(int);

    //对于非空类型转换成值类型
    int v;
    int? r = 5;
    v = r is int? ?  (int)r : 0;
</code></pre>
<p>  is关键字会对给定类型进行检测其是否兼容(对对象检测是否是is后面类型的类或派生类，因此这是安全的),并返回一个bool类型；</p>
<p>  注意is的左边不能是匿名方法(lambda表达式除外)。</p>
</li>
</ul>

    </div>
    
    <div class="footer">
    <hr>
        <font> ©2021 </font>
        <a target="_blank" rel="noopener" href="https://github.com/Gatongone/" style="color: rgb(214, 207, 218);">Gatongone</a>
        some copyrights reserved
        <div style="float: right; margin-right: -200px;">
              Feb 15th  2021,  3:02:22  |
            <font>Powered by</font>
            <a target="_blank" rel="noopener" href="https://hexo.io/"  style="color: rgb(214, 207, 218);">Hexo</a>
            framework
        </div>
    </div>
</body>
    



</div>



<script>
     var bar=document.getElementById("top_btn")
     var showtime=0;
     var hidetime=0;
     window.addEventListener("pageshow",function(){
         let scrollTop = window.pageYOffset ||document.documentElement.scrollTop|| document.body.scrollTop || 0;
        if(scrollTop ==0)
        {
            bar.style.display = 'none';
        }
        else
        {
            bar.style.display = 'block';
        }
        window.addEventListener("scroll",function(){
            bar.style.display = 'block';
            scrollTop = window.pageYOffset ||document.documentElement.scrollTop|| document.body.scrollTop || 0;
            if(scrollTop != 0)
            {
                if(hidetime==0)
                {
                    bar.classList.toggle("top_btn_show");
                    hidetime++;
                }
                showtime=0;
            }  
            else
            {
                if(showtime==0 && hidetime!=0)
                {
                    bar.classList.toggle("top_btn_show");
                    showtime++;
                    hidetime=0;
                }
            }
        }) 
     })
     
    var timer = null;
    bar.onclick = function()
    {
        cancelAnimationFrame(timer);
        timer = requestAnimationFrame(function fn()
        {
            var top = document.body.scrollTop || document.documentElement.scrollTop;
            if(top > 0)
            {
                document.body.scrollTop = document.documentElement.scrollTop = top - 80;
                timer = requestAnimationFrame(fn);
            }
            else
            {
                cancelAnimationFrame(timer);
            } 
        });
    }
         
</script>

<script src="//cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>


</body>                                             <!--  加载主体  -->

        </div>                                                                 
        
<script src="/blog/js/searchbar.js"></script>
<script src="/blog/js/hidebar.js"></script>
              <!--    加载JS  -->                                                          
    </body>

</html>