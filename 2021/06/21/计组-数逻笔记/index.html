<!DOCTYPE html>
<html lang="ch">

<head>
    <meta charset="UTF-8">
    <meta name="Author" content="Gatongone">
    <meta name="Description" content="Gatongone's Blog">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/x-icon"  href="/images/NeonGame_L.ico">
    <link rel="icon" type="image/x-icon"  href="/images/NeonGame_M.ico">
    <link rel="icon" type="image/x-icon"  href="/images/NeonGame_S.ico">
    <style>
        body
        {
            background-color: rgb(20, 20, 34);
            -ms-overflow-style: none; /* IE 10+ */
            scrollbar-width: none; /* Firefox */
            overflow-x: hidden;
            height: 100%;
        }
        body::-webkit-scrollbar
        {
            display: auto; /* Chrome Safari */
            width: 0px;
        }
    </style>
<meta name="generator" content="Hexo 5.3.0"></head>

    <body>
        
<link rel="stylesheet" href="/blog/css/leftsidebar.css">

<div class="leftpanel_out" id="leftpanel_out">
    <div class="block1"></div>

    <div class="profile_background" id="profile_background">
        <a href="/blog/" target="_self">
            <img class="profile" src="/blog/images/profile.jpg" />
        </a>
    </div>

    <img class="block2" src="/blog/images/block.png"/>

    <div class="buttons">
        <a>
           
        </a>
        <a target="_blank" rel="noopener" href="https://space.bilibili.com/26209665" title="bilibili">
            <img class="shadowfilter bilibili" src="/blog/images/icon/bilibili_btn.png"/>
        </a>
         <a>
           
        </a>
        <a target="_blank" rel="noopener" href="https://gatongone.lofter.com/" title="lofter">
            <img class="shadowfilter lofter" src="/blog/images/icon/lofter_btn.png"/>
        </a>
         <a>
           
        </a>
         <a target="_blank" rel="noopener" href="https://github.com/Gatongone/" title="github">
            <img class="shadowfilter github" src="/blog/images/icon/github_btn.png"/>
        </a>
         <a>
           
        </a>
        <a target="_blank" rel="noopener" href="https://blog.csdn.net/Gatongone" title="CSDN">
            <img class="shadowfilter csdn" src="/blog/images/icon/csdn_btn.png"/>
        </a>
    </div>
    <div class="block3"></div>
</div>
<script>
    // var obj=document.getElementById('leftpanel_out');
    // MoveBar(obj,"leftpanel_in",1150)
</script>                       <!-- 加载侧边栏 -->

        <div class='body-wrapper' id="body-wrapper">

            <head>
 <link rel="icon" type="image/x-icon"  href="/images/NeonGame_L.ico">
 <link rel="icon" type="image/x-icon"  href="/images/NeonGame_M.ico">
 <link rel="icon" type="image/x-icon"  href="/images/NeonGame_S.ico">
 <link href="https://cdn.bootcss.com/KaTeX/0.7.1/katex.min.css" rel="stylesheet">
 
</head>
<body>
    
<link rel="stylesheet" href="/blog/css/topbar.css">


<script src="/blog/js/searchbar.js"></script>
  
<div class="topbar" id="topbar">
    <div class = "top_left" id="top_left">
    <a href="https://www.gatongone.site" target="_self">
        <img src="/blog/images/NeonGame.png"/>
    </a>
        <font class="title_top" id="title_top" align="left">Gatongone's blog</font>
    </div>
    <div id="topblock">
            <nav>
                <input type="checkbox" id="nav"/><label for="nav" class="check" id="check"></label>
                <ul>
                    <li><a href="#" id='about' class="buttonfont">About</a></li>
                    <li><a href="#" id="plan" class="buttonfont">Planing</a></li>
                    <li><a href="#" id="RSS" class="buttonfont">RSS</a></li>
                </ul>
            </nav>
    </div>
    <div id="search">
        <input id="search_input"  type="text" placeholder="search with title" value="" onkeydown=" if(event.which==13)''">
        <button><img src="/blog/images/icon/search.png" style="height: 16px; width: 18px; margin-top: 2px;"></button>
    </div>
</div>

<!-- swiftype search -->

<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');
  
  _st('install','ZLY73zc1DgdsrmGd9LyN','2.0.0');
</script>



<script src="/blog/js/hidebar.js"></script>

    
<link rel="stylesheet" href="/blog/css/mainbody.css">


<!-- 回到首页 -->

    <a href="/blog/">
    <button class="home_btn" >
        <img src="/blog/images/icon/home.png">
    </button>
    </a>


<!-- 回到顶部 -->
<div id="top">
    <button class="top_btn" id="top_btn">
        <img src="/blog/images/icon/top.png">
    </button>
</div>
<!-- 主体 -->

<div class="mainbody" id="mainbody">
<!-- 加载post_entry -->
    <div class="entry">
    

    
<!--    加载post    -->    

    
        <head>
    <title>计组&数逻笔记</title>
    <link rel="icon" type="image/x-icon"  href="/images/NeonGame_L.ico">
    <link rel="icon" type="image/x-icon"  href="/images/NeonGame_M.ico">
    <link rel="icon" type="image/x-icon"  href="/images/NeonGame_S.ico">
</head>
<body>

    
<link rel="stylesheet" href="/blog/css/post.css">

    
<link rel="stylesheet" href="/blog/css/hightlight.css">


    
<link rel="stylesheet" href="/blog/css/rightbar.css">

<div id="right_bar">

        

        
            <div id="post_index" class="post_index">
                <span> Post Index </span>
                <div>
                    <div id="clear"></div>
                    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A6%82%E8%AE%BA"><span class="toc-text"> 计算机概论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%88%86%E7%B1%BB%E6%95%B0%E5%AD%97%E8%AE%A1%E7%AE%97%E6%9C%BA-%E6%A8%A1%E6%8B%9F%E8%AE%A1%E7%AE%97%E6%9C%BA"><span class="toc-text"> 计算机的分类：数字计算机、模拟计算机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2"><span class="toc-text"> 计算机的发展史：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="toc-text"> 计算机性能指标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%B1%82%E7%BA%A7"><span class="toc-text"> 计算机系统层级</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E7%BB%93%E6%9E%84%E8%AE%A1%E7%AE%97%E6%9C%BA"><span class="toc-text"> 冯·诺依曼结构计算机</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-text"> 特点：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E8%BF%9B%E5%88%B6%E5%BF%AB%E9%80%9F%E6%8D%A2%E6%88%90%E4%BA%8C%E8%BF%9B%E5%88%B6"><span class="toc-text"> 十进制快速换成二进制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9C%9F%E5%80%BC%E5%92%8C%E6%9C%BA%E5%99%A8%E7%A0%81"><span class="toc-text"> 真值和机器码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BC%95%E5%85%A5%E6%9C%BA%E5%99%A8%E7%A0%81"><span class="toc-text"> 为什么要引入机器码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F"><span class="toc-text"> 数据格式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E4%BB%A5%E8%A1%A5%E7%A0%81%E5%AD%98%E5%82%A8"><span class="toc-text"> 整数：以补码存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0"><span class="toc-text"> 浮点数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ieee754%E6%A0%87%E5%87%86"><span class="toc-text"> IEEE754标准</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A5%E7%A0%81%E8%BF%90%E7%AE%97"><span class="toc-text"> 补码运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A5%E7%A0%81%E5%8A%A0%E6%B3%95x%E8%A1%A5-y%E8%A1%A5-xy%E8%A1%A5"><span class="toc-text"> 补码加法：[x]补 + [y]补 &#x3D; [x+y]补</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A5%E7%A0%81%E5%87%8F%E6%B3%95x%E8%A1%A5-y%E8%A1%A5-x%E8%A1%A5-y%E8%A1%A5-x-y%E8%A1%A5"><span class="toc-text"> 补码减法：[x]补 - [y]补 &#x3D; [x]补 + [-y]补 &#x3D; [x-y]补</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%A2%E5%87%BA%E5%88%A4%E6%96%AD"><span class="toc-text"> 溢出判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%A0%81%E4%B8%80%E4%BD%8D%E4%B9%98"><span class="toc-text"> 原码一位乘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A5%E7%A0%81%E4%B8%80%E4%BD%8D%E4%B9%98"><span class="toc-text"> 补码一位乘</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E8%BF%90%E7%AE%97"><span class="toc-text"> 浮点数运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E5%87%8F%E6%B3%95"><span class="toc-text"> 加减法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%98%E6%B3%95%E9%99%A4%E6%B3%95"><span class="toc-text"> 乘法除法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E4%BB%A3%E6%95%B0"><span class="toc-text"> 逻辑代数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E9%87%8F%E5%92%8C%E6%A8%A1%E6%8B%9F%E9%87%8F"><span class="toc-text"> 数字量和模拟量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%BC%E9%9B%B7%E7%A0%81"><span class="toc-text"> 格雷码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%AE%9A%E5%BE%8B"><span class="toc-text"> 基本定律</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%A7%84%E5%88%99"><span class="toc-text"> 基本规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%A1%E8%AF%BA%E5%9B%BE"><span class="toc-text"> 卡诺图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E9%A1%B9"><span class="toc-text"> 最小项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E9%A1%B9%E7%BC%96%E5%8F%B7"><span class="toc-text"> 最小项编号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E9%A1%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text"> 最小项表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E7%BB%84%E5%90%88%E5%90%88%E5%B9%B6%E6%9C%80%E5%B0%8F%E9%A1%B9%E5%B9%B6%E5%87%8F%E5%B0%8F%E5%8F%98%E9%87%8F"><span class="toc-text"> 通过组合合并最小项并减小变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91"><span class="toc-text"> 数字逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91"><span class="toc-text"> 组合逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91"><span class="toc-text"> 时序逻辑</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F"><span class="toc-text"> 存储系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text"> 存储器的分类：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-text"> 主存储器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-text"> 半导体存储器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rom"><span class="toc-text"> ROM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-text"> 并行存储器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cache%E9%AB%98%E9%80%9F%E7%BC%93%E5%86%B2%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-text"> Cache高速缓冲存储器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-text"> 虚拟存储器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F"><span class="toc-text"> 指令系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F"><span class="toc-text"> 指令格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E5%AF%BB%E5%9D%80"><span class="toc-text"> 指令寻址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AF%BB%E5%9D%80"><span class="toc-text"> 数据寻址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cisc%E5%92%8Crisc"><span class="toc-text"> CISC和RISC</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8cpu"><span class="toc-text"> 中央处理器CPU</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E5%92%8C%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="toc-text"> 指令周期和数据流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E5%B8%83%E7%BA%BF%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-text"> 硬布线控制器的设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-text"> 微程序控制器的设计</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BA%BF"><span class="toc-text"> 总线</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BA%BF%E7%9A%84%E4%BB%B2%E8%A3%81"><span class="toc-text"> 总线的仲裁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#io%E7%B3%BB%E7%BB%9F"><span class="toc-text"> I&#x2F;O系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F"><span class="toc-text"> 程序查询方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%96%AD%E6%96%B9%E5%BC%8F"><span class="toc-text"> 程序中断方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dma%E6%96%B9%E5%BC%8F"><span class="toc-text"> DMA方式</span></a></li></ol></li></ol>
                </div>
                
             </div>
        
             
</div>


    <div class="page_title" id="page_title">
        计组&数逻笔记
    </div>
    <hr>
    <div class="page_content">
        
        
        <ul>
<li>
<h2 id="计算机概论"><a class="markdownIt-Anchor" href="#计算机概论"></a> 计算机概论</h2>
<ul>
<li>
<h3 id="计算机的分类数字计算机-模拟计算机"><a class="markdownIt-Anchor" href="#计算机的分类数字计算机-模拟计算机"></a> 计算机的分类：数字计算机、模拟计算机</h3>
</li>
<li>
<h3 id="计算机的发展史"><a class="markdownIt-Anchor" href="#计算机的发展史"></a> 计算机的发展史：</h3>
<ul>
<li>一代目：电子管计算机</li>
<li>二代目：晶体管计算机</li>
<li>三代目：中小规模集成电路计算机（小型计算机）</li>
<li>四代目：大/超大规模集成电路计算机（微型计算机）</li>
<li>五代目：巨大规模集成电路计算机：单片机</li>
</ul>
</li>
<li>
<h3 id="计算机性能指标"><a class="markdownIt-Anchor" href="#计算机性能指标"></a> 计算机性能指标</h3>
<ul>
<li>主频</li>
<li>总线宽度</li>
<li>存储器容量和带宽</li>
<li>吞吐量</li>
<li>响应时间</li>
<li>利用率</li>
<li>处理机字长</li>
</ul>
</li>
<li>
<h3 id="计算机系统层级"><a class="markdownIt-Anchor" href="#计算机系统层级"></a> 计算机系统层级</h3>
<ul>
<li>微程序级</li>
<li>机器级</li>
<li>操作系统级</li>
<li>汇编语言级</li>
<li>高级语言级</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr />
<ul>
<li>
<h2 id="冯诺依曼结构计算机"><a class="markdownIt-Anchor" href="#冯诺依曼结构计算机"></a> 冯·诺依曼结构计算机</h2>
<p>冯·诺依曼结构计算机首次提出了存储程序的思想</p>
<ul>
<li>
<h3 id="特点"><a class="markdownIt-Anchor" href="#特点"></a> 特点：</h3>
<ul>
<li>串行执行指令</li>
<li>存储器：指令和数据放在一个存储器中（只有一条总线），按地址进行线性的访问，因此是一维的结构</li>
<li>数据形式：二进制</li>
<li>以运算器为中心：I/O设备与存储器之间的数据传输都要经过运算器</li>
<li>指令的组成：操作码+地址</li>
</ul>
<p>根本特征：两个一维性：<code>一维的计算模型</code>（串行执行）、<code>一维的存储模型</code>（按址线性访问）</p>
</li>
<li>
<p>非冯诺依曼结构的计算机：</p>
<ul>
<li>哈佛型计算机：
<ul>
<li>两个存储器：一个放指令，一个放数据（因此有两条总线），可以同时执行取指令和存放数据的操作，是二维结构。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr />
<ul>
<li>
<h2 id="十进制快速换成二进制"><a class="markdownIt-Anchor" href="#十进制快速换成二进制"></a> 十进制快速换成二进制</h2>
<p>比如十进制38：</p>
<ul>
<li>写出所有比38小的次幂数字：32，16，8，4，2，1</li>
<li>然后从32——&gt;1逐渐相加，相加时比38大则算0，否则算1</li>
<li>32（1），16（0），8（0），4（1），2（1），1（0）</li>
<li>因此(38)10 = (100110)2</li>
</ul>
<p>小数的处理<br />
比如十进制0.53</p>
<ul>
<li>0.53 × 2 = 1.06 取整数部分 1</li>
<li>0.06 × 2 = 0.12 取整数部分 0</li>
<li>0.12 × 2 = 0.24 取整数部分 0</li>
<li>0.24 × 2 = 0.48 取整数部分 0</li>
<li>…直到 × 2 后结果为1为止，否则只能不断扩大精度</li>
<li>结果:0.100…</li>
</ul>
</li>
</ul>
<hr />
<ul>
<li>
<h2 id="真值和机器码"><a class="markdownIt-Anchor" href="#真值和机器码"></a> 真值和机器码</h2>
<ul>
<li>
<p>真值 ：真正的值，比如<code>38</code></p>
</li>
<li>
<p>机器码：机器中表示的数</p>
<ul>
<li>原码：符号位0表示正，1表示负,真值的二进制加上符号位一共8位
<ul>
<li>比如真值是<code>38</code>时，原码为：<code>01001100</code></li>
</ul>
</li>
<li>反码：正数时与原码一致，负数时符号位仍是1，数值位直接对原码取反
<ul>
<li>比如原码：<code>10010110</code> 则反码：<code>11101001</code></li>
</ul>
</li>
<li>补码：
<ul>
<li>已只原码求补码：正数时和原码一致，负数时对除了符号位全部取反，再加1进行运算
<ul>
<li>比如原码：<code>11001100</code> 则补码：先取反：<code>10110011</code>，再加1：<code>10110100</code></li>
</ul>
</li>
<li>已知补码求原码：正数时原码就是该补码，负数时原码是该补码的补码
<ul>
<li>比如补码：<code>11111001</code> 则原码：先取反：<code>10000110</code>，再加1：<code>10000111</code></li>
</ul>
</li>
</ul>
</li>
<li>移码：符号位对补码取反，数值位与补码相同
<ul>
<li>比如原码：<code>11001100</code> 则补码：<code>10110100</code>，则移码：<code>00110100</code></li>
</ul>
</li>
</ul>
<h3 id="为什么要引入机器码"><a class="markdownIt-Anchor" href="#为什么要引入机器码"></a> 为什么要引入机器码</h3>
<p>为了让机器进行加减乘除的运算，需要让计算机对<code>符号位</code>进行处理，而让<code>机器识别符号位会增加电路设计成本</code>，因此提出了<code>符号位参与运算的方法</code>。</p>
<p>根据运算法则<code>1-1 = 1+(-1)</code>，因此为了简化设计，机器只有加法没有减法。</p>
<ul>
<li>
<p>反码：</p>
<p>原码的出现保证了符号位可以参与运算并且只保留加法，比如<code>1+1</code>：</p>
<p><code>[00000001]原 + [00000001]原 = [00000010]原 = 2</code></p>
</li>
<li>
<p>反码：</p>
<p>虽然原码可以正常处理加法，但是对减法处理则会导致一些问题，比如<code>1-1</code>：</p>
<p><code>[00000001]原 + [10000001]原 = [10000010]原 = -2</code></p>
<p>为了解决原码减法的问题，因此引入了反码：</p>
<pre class="highlight"><code class="">  [00000001]原 + [10000001]原
= [00000001]反 + [11111110]反
= [11111111]反
= [10000000]原
= -0
</code></pre>
</li>
<li>
<p>补码：</p>
<p>虽然反码解决了减法的问题，但是由于符号位的原因导致<code>-0 和 +0 的的原码分别为[00000000]原 和 [10000000]原</code>。虽然 +0 和 -0 在理解上是一样的，但是0带符号位是没有任何意义的，这将由两个编码来表示0，这将会出现这种情况<code>1+(-0)</code>：</p>
<p><code>[00000001]原 + [10000000]原 = [1000001]原 = -1</code></p>
<p>于是引入了补码，解决了0的符号和两个编码的问题，比如<code>1-1</code></p>
<pre class="highlight"><code class="">  [00000001]原 + [10000001]原
= [00000001]补 + [11111111]补
= [00000000]补
= [00000000]原
= -0
</code></pre>
<p>因此在补码中只有 -0 而 没有 +0 其中 <code>[00000000]补 真值为0，而[10000000]补 真值为-128</code>：</p>
<pre class="highlight"><code class="">  (-1) + (-127)
= [10000001]原 + [11111111]原
= [11111111]补 + [10000001]补
= [10000000]补
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr />
<ul>
<li>
<h2 id="数据格式"><a class="markdownIt-Anchor" href="#数据格式"></a> 数据格式</h2>
<ul>
<li>
<h3 id="整数以补码存储"><a class="markdownIt-Anchor" href="#整数以补码存储"></a> 整数：以补码存储</h3>
</li>
<li>
<h3 id="浮点数"><a class="markdownIt-Anchor" href="#浮点数"></a> 浮点数</h3>
<p>机器中一个二进制的浮点数a分别由两个数m和e来表示（规格化）：a = m × b<sup>e</sup>，比如 11.01B = 0.1101B × 2<sup>2</sup></p>
<p>其中：</p>
<ul>
<li>m表示尾数，一个纯小数，包括整数和小数部分</li>
<li>b表示基数，一般是2</li>
<li>e表示阶码，某个整数表示该浮点精确到第几位</li>
</ul>
<p>下面表示浮点数计算机中的存储结构，其中阶符表示指数的符号，阶码表示指数的二进制部分，数符表示整个浮点数的符号，尾数表示浮点数中整数和小数部分</p>
<table>
<thead>
<tr>
<th>阶符±</th>
<th>阶码e</th>
<th>数符±</th>
<th>尾数m</th>
</tr>
</thead>
<tbody></tbody>
</table>
</li>
<li>
<h3 id="ieee754标准"><a class="markdownIt-Anchor" href="#ieee754标准"></a> IEEE754标准</h3>
<p>根据国际标准IEEE规定，任何一个二进制的浮点数都可以表示为：(-1)<sup>S</sup>  * 2<sup>E</sup> * M</p>
<ul>
<li>S表示符号，1bit，0位正，1为负</li>
<li>M表示尾数，23bit，因为尾数域最左边总是1，因此一般省略不写</li>
<li>E表示阶码，8bit，用移码表示(阶码真值 + 127)</li>
</ul>
<p>比如上面的 <code>11.01B</code> 在IEEE754标准下就可以表示为</p>
<table>
<thead>
<tr>
<th>S符号位（1bit）</th>
<th>E阶码（8bit）</th>
<th>M尾数（23bit）</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>10001011</td>
<td>110100000000000000000000</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
</ul>
<hr />
<ul>
<li>
<h2 id="补码运算"><a class="markdownIt-Anchor" href="#补码运算"></a> 补码运算</h2>
<ul>
<li>
<h3 id="补码加法x补-y补-xy补"><a class="markdownIt-Anchor" href="#补码加法x补-y补-xy补"></a> 补码加法：<code>[x]补 + [y]补 = [x+y]补</code></h3>
</li>
</ul>
<pre class="highlight"><code class="">x = +1001，y = +0101，求 x + y =?

[x]补= 01001，[y]补=00101

    [x]补	01001
+   [y]补	00101
___________________
  [x+y]补   01110

∴ x + y = +0110   
</code></pre>
<ul>
<li>
<h3 id="补码减法x补-y补-x补-y补-x-y补"><a class="markdownIt-Anchor" href="#补码减法x补-y补-x补-y补-x-y补"></a> 补码减法：<code>[x]补 - [y]补 = [x]补 + [-y]补 = [x-y]补</code></h3>
<p>其中 [-y]补 = -[y]补 + 1 (变补)</p>
<p>例如：</p>
<p>若 [x]补 = 10010<br />
则 [-x]补 = -[x]补 + 1 = 01101 + 00001 = 01110</p>
<pre class="highlight"><code class="">x = +0101，y = +0110，求 x - y =?

[x]补= 00101，[y]补=00110
[-y]补 = 11001 + 00001 = 11010

 [x]补	00101
+  [-y]补	11010
___________________
[x+y]补   11111

∴ x - y = -00001
</code></pre>
</li>
<li>
<h3 id="溢出判断"><a class="markdownIt-Anchor" href="#溢出判断"></a> 溢出判断</h3>
<p>在补码进行加减运算后，若数值超过2<sup>n-1</sup>  ~  -2<sup>n-1</sup> 所能表示的范围则会发生溢出</p>
<p>发生溢出的情况：</p>
<ul>
<li>两正数相加变负数，正溢。</li>
<li>两负数相加变正数，负溢。</li>
</ul>
<p>溢出检测方法：</p>
<ul>
<li>
<p>双符号位法(变形补码+)：</p>
<p>运算时正数符号位位00，负数符号位为11，运算结果按下表判断是否溢出</p>
<table>
<thead>
<tr>
<th>位2</th>
<th>判断</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>0|0|正确（正数）<br />
1|1|正确（负数）<br />
0|1|正溢<br />
1|0|负溢</p>
<p>例如</p>
<pre class="highlight"><code class=""></code></pre>
</li>
</ul>
<p>x = +1001，y = -0101，求 x + y =?</p>
<p>[x]补= 00 01001，[y]补= 11 11011</p>
<pre><code>  [x]补	00 01001
</code></pre>
<ul>
<li>[y]补	11 11011</li>
</ul>
<hr />
<pre><code>[x+y]补   00 00100
</code></pre>
<p>00正确，直接变成0</p>
<p>∴ x - y = +0100<br />
```</p>
<pre><code>  ``` 
</code></pre>
<p>x = +0110，y = +0100，求 x + y =?</p>
<p>[x]补= 00 1100，[y]补= 00 0100</p>
<pre><code>  [x]补	00 1100
</code></pre>
<ul>
<li>[y]补	00 0100</li>
</ul>
<hr />
<pre><code>[x+y]补   01 0110
</code></pre>
<p>01错误，正溢<br />
```</p>
</li>
<li>
<h3 id="原码一位乘"><a class="markdownIt-Anchor" href="#原码一位乘"></a> 原码一位乘</h3>
<p>要了解补码一位乘首先需要知道原码一位乘</p>
<p>由于手算原码乘法存在一些问题：小数点如何移动，加法器无法解决n个数一次性相加…</p>
<p>因此为了解决这些问题需要将算法进行改造</p>
<p>乘法需要用到三个寄存器：</p>
<ul>
<li>A：存放累加和（或者叫部分积）和数值高位</li>
<li>B：存放被乘数（取绝对值）</li>
<li>C：存放乘数和数值低位（取绝对值）</li>
</ul>
<p>计算过程：</p>
<ul>
<li>
<ol>
<li>A 根据 <code>C的最低位来判断</code> 是<code>加B</code> 还是<code>加0</code></li>
</ol>
</li>
<li>
<ol start="2">
<li>累加后将A和右移一位 在重复 1.</li>
</ol>
</li>
<li>
<ol start="3">
<li>将累加后的结果A和C进行拼接作为数值位，A和B的异或结果作为符号位</li>
</ol>
</li>
</ul>
<pre class="highlight"><code class="">  例：计算 [0.1101]原 * [0.1011]原

        部分积A        乘数C            累加操作              说明
  (0)   00.0000       0.1011                                初始化寄存器,B中始终存0.1101

  (1)   00.0000       0.1011                       

            00.0000
          + 00.1101                      +B          
          ——————————
            00.1101

  (2)   00.1101       0.1011                                 A和C均向右移一位 
        00.0110       10.101                                 把从A中移出的部分放到C最高位

            00.0110
          + 00.1101                      +B                  由于C的最低位是1，所以+B
          ——————————
            01.0011
  (3)   01.0011       10.101                                 A和C均向右移一位
        00.1001       11.010                                 把从A中移出的部分放到C最高位

            00.1001
          + 00.0000                      +0                  由于C的最低位是0，所以+B
          ——————————
            00.1001
  
  (4)   00.1001       11.010                                 A和C均向右移一位
        00.0100       111.01                                 把从A中移出的部分放到C最高位

            00.0100
          + 00.1101                      +B                  由于C的最低位是1，所以+B
          ——————————
            01.0001
  
  (5)   01.0001       111.01                                 由于A的最低位是1所以A和C均向右移一位
        00.1000       1111.0                                 把从A中移出的部分放到C最高位
        1000          1111                                   保留有效部分:A小数部分前4个，C整数部分前4个

    结果:  符号位对AB的符号位进行异或运算（相同为0，相反为1）： 0 
          数值位：直接将A和C中有效部分进行拼接： 10001111

          因此[0.1101]原 * [0.1011]原 = [0.10001111]原
</code></pre>
<ul>
<li>
<h3 id="补码一位乘"><a class="markdownIt-Anchor" href="#补码一位乘"></a> 补码一位乘</h3>
<p>booth（比较法）</p>
<p>与原码一位乘类似，一样也需要3个寄存器，但是只有C取绝对值：</p>
<ul>
<li>A：存放累加和（或者叫部分积实际上是数值高位）</li>
<li>B：存放被乘数</li>
<li>C：存放乘数和数值低位（取绝对值）</li>
</ul>
<p>计算过程与原码一位乘类似，A 根据 <code>C的最低两位</code>来判断 是<code>加B</code> 还是 <code>减</code>B 还是 <code>加0</code>，booth算法需要遵循下表</p>
<p>C倒数第二位|C倒数第一位|运算操作</p>
<p>------|------|------<br />
0|1|右移一位+B<br />
1|0|右移一位-B<br />
0|0|右移一位+0<br />
1|1|右移一位+0</p>
<p>在计算结束后还需要根据该表来进行校正</p>
<pre class="highlight"><code class="">  例：计算 X=-0.1101，Y=-0.1011，计算[XY]补

  初始化寄存器：
  A = 00.0000
  B = [X]补 = 11.0011
 -B = [-X]补 = 00.1101
  C = [Y]补 = 1.0101

        部分积A     乘数C            累加操作              说明
  (0)   00.0000   1.01010                           初始化寄存器,并在C末尾补个0

  (1)   00.0000   1.01010                       

            00.0000
          + 00.1101                   + -B          由于C对最后两位是10所以-B
          ——————————
            00.1101

  (2)   00.1101   1.01010                           A和C均向右移一位 
        00.0110   11.0101                           把从A中移出的部分放到C最高位

            00.0110
          + 11.0011                   +B            由于C对最后两位是01所以+B
          ——————————
            11.1001
  
  (3)   11.1001   11.0101                           A和C均向右移一位，由于A现在是负数，所以要在左边补1
        11.1100   111.010                           把从A中移出的部分放到C的最高位

            11.1100
          + 00.1101                   + -B          由于C对最后两位是10所以-B
          ——————————
           100.0001
            00.1001                                 发生了进位只保留有效位
  
  (4)   00.1001   111.010                           A和C均向右移一位
        00.0100   1111.01                           把从A中移出的部分放到C的最高位

            00.0100
          + 11.0011                   +B            由于C对最后两位是01所以+B
          ——————————
            11.0111
  
  (5)   11.0111   1111.01                           A和C均向右移一位，由于A现在是负数，所以要在左边补1
        11.1011   11111.0                           把从A中移出的部分放到C的最高位

    校正：  
            11.1011
          + 00.1101                   +B            由于C对最后两位是10所以-B
          ——————————
           100.1000
            00.1000                                 发生了进位只保留有效位

        00.1000  11111.0
        1000     1111                               保留有效部分:A小数部分前4个，C整数部分前4个

    结果:  符号位直接取A的：0
          数值位：直接将A和Cn中数值位拼接： 10001111

          因此[XY]补 = 00.1000111 = +0.10001111
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr />
<ul>
<li>
<h2 id="浮点数运算"><a class="markdownIt-Anchor" href="#浮点数运算"></a> 浮点数运算</h2>
<ul>
<li>
<h3 id="加减法"><a class="markdownIt-Anchor" href="#加减法"></a> 加减法</h3>
<p>ps: 尽量采用双符号位，方便判断是否溢出。</p>
<p>分为五步：</p>
<p>举例：X = 00.1110 × 2<sup>3</sup>，Y =  00.1001 × 2<sup>4</sup>，求X + Y</p>
<ol>
<li>
<p>对阶：把阶数小的浮点数向阶数大的变化。</p>
<p>这里X阶数是3，比Y的阶数小因此 X = 00.1110 × 2<sup>3</sup> = 00.01110 × 2<sup>4</sup></p>
</li>
<li>
<p>对尾数进行相加减</p>
<pre class="highlight"><code class="">    00.01110
+   00.1001  
——————————————
    01.00001
</code></pre>
</li>
<li>
<p>规格化</p>
<p>只有两种情况需要规格化，其他情况保持不变：</p>
<ul>
<li>
<p>运算结果的符号位不同时（比如 10.xxxxx 或 01.xxxxx），右规（运算结果的尾数向右移一位），然后阶码+1</p>
<p>比如上面的运算结果 01.00001 符号位不同，因此右规，变成00.100001（正数补0），阶码-1</p>
<p>或者10.11101 符号位不同，溢出右规，变成11.011101（负数补1），阶码-1</p>
</li>
<li>
<p>运算结果的符号位相同，但最高位与符号位相同时（比如11.1xxxxxx 或 00.0xxxxxx），左规（运算结果的尾数向左移直到最高位与符号位不同为止），然后阶码-n（n表示移动了几位）</p>
<p>比如00.001010，最高位和符号位都是0，因此左归：00.1010，阶码-2</p>
</li>
</ul>
</li>
<li>
<p>舍入</p>
<p>在对阶或右规时，可能在尾数低位部分加上一部分值，以保证位数和原来的数值相同。</p>
<p>一般有两种方法：</p>
<ul>
<li>
<p>0舍1入法：如果舍去的最高位是0，则不管；如果舍去的最高位是1，则在尾数末尾+1</p>
<p>比如 11.11001001 要舍掉的部分是1001，最高位是1，因此舍入后：11.1101</p>
<p>如果舍入后又出现溢出，则继续右规再舍入</p>
</li>
<li>
<p>置1法：去掉多余的尾数，并保证去掉后的最后一位是1（如果是0则改成1）</p>
<p>比如 00.100001 舍入后：00.10001，但这种做法精度并不高，但简单</p>
</li>
</ul>
</li>
<li>
<p>检查阶码溢出</p>
<p>右规或左规都可能导致阶码溢出</p>
<p>如果上溢（阶码符号位为01），则进行中断处理</p>
<p>如果下溢（阶码符号位为10），则阶码和尾数全部置0(也叫做机器零处理)</p>
<pre class="highlight"><code class="">x = 101.1，y = -10.01 设浮点数阶码取三位,尾数取4位求 x + y = ?

解：

x = +101.1 = +0.1011 * 2^3 = 00.1011 * 2^(00 101)
y = -10.01 = -0.1001 * 2^2 = 11.1001 * 2^(00 010)

1.对阶：

y = 11.01001 *  2^(00 101)

2.尾数相加减:

  00.1011
+ 00.01001
————————————
  00.11111

3.规格化：

00.11111符号位为00，最高位为1，因此不需要规格化

4.舍入：

采用置1法：

舍入后：00.1111

5.检查阶码溢出

阶码仍为00 101符号位为00 因此不溢出

因此x + y = 0.1111 * 2^(00 101) = 111.1
</code></pre>
</li>
</ol>
</li>
<li>
<h3 id="乘法除法"><a class="markdownIt-Anchor" href="#乘法除法"></a> 乘法除法</h3>
<p>分为三步：</p>
<p>比如 X = 00.1011 * 2^(00 101)，Y = 11.1001 * 2^(00 010),求X × Y</p>
<ol>
<li>求阶和/差：</li>
</ol>
<pre class="highlight"><code class="">    00 101
  + 00 010
  ——————————
    00 111
</code></pre>
<ol>
<li>
<p>尾数相乘/相除</p>
<pre class="highlight"><code class="">      A         C          操作
    00.0000
  + 00.1011    .1001        +B
  ——————————
    00.1011
    00.0101    1.100
  + 00.0000                 +0
  ——————————   
    00.0101
    00.0010    11.10
  + 00.0000                 +0
  ——————————
    00.0010
    00.0001    111.1
  + 00.1011                 +B
  ——————————
    00.1100    1111.

因此相乘结果为: 00.11001111
</code></pre>
</li>
<li>
<p>规格化</p>
<p>浮点数乘除运算的结果中，由于乘积和商的绝对值一定小于1，因此只存在左规不存在右规</p>
<p>这里不需要进行规格化</p>
</li>
<li>
<p>舍入：</p>
<p>直接用置1法：00.1101</p>
</li>
<li>
<p>溢出判断</p>
<p>阶码00 111符号位仍为00，因此无溢出</p>
<p>因此 X × Y = 0.1101 × 2<sup>7</sup></p>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<hr />
<ul>
<li>
<h2 id="逻辑代数"><a class="markdownIt-Anchor" href="#逻辑代数"></a> 逻辑代数</h2>
<ul>
<li>
<h3 id="数字量和模拟量"><a class="markdownIt-Anchor" href="#数字量和模拟量"></a> 数字量和模拟量</h3>
<p>数字量是离散的，表现为非连续的离散点，比如苹果的个数等</p>
<p>模拟量是连续的，表现为连续变换的变量，比如温度和电压等</p>
</li>
<li>
<h3 id="格雷码"><a class="markdownIt-Anchor" href="#格雷码"></a> 格雷码</h3>
<p>格雷码保证了信号量变换时只有一位的变换,若低位都变过则高一位变，否则从最低位开始变</p>
<table>
<thead>
<tr>
<th>十进制</th>
<th>二进制</th>
<th>格雷码</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0000</td>
<td>0000</td>
</tr>
<tr>
<td>1</td>
<td>0001</td>
<td>0001</td>
</tr>
<tr>
<td>2</td>
<td>0010</td>
<td>0011</td>
</tr>
<tr>
<td>3</td>
<td>0011</td>
<td>0010</td>
</tr>
<tr>
<td>4</td>
<td>0100</td>
<td>0110</td>
</tr>
<tr>
<td>5</td>
<td>0101</td>
<td>0111</td>
</tr>
<tr>
<td>6</td>
<td>0110</td>
<td>0101</td>
</tr>
<tr>
<td>7</td>
<td>0111</td>
<td>0100</td>
</tr>
<tr>
<td>8</td>
<td>1000</td>
<td>1100</td>
</tr>
<tr>
<td>9</td>
<td>1001</td>
<td>1101</td>
</tr>
</tbody>
</table>
<p>格雷码转二进制码，方法是：二进制的最高位和格雷码一致，其余的位用二进制的前一位与格雷码的后一位做异或运算,相同为0，相异为1</p>
<p><img src="GrayCode.jpg" alt="alt" style="max-width:100%;"  /></p>
</li>
<li>
<h3 id="基本定律"><a class="markdownIt-Anchor" href="#基本定律"></a> 基本定律</h3>
<p><img src="%E9%80%BB%E8%BE%91%E4%BB%A3%E6%95%B0%E5%9F%BA%E6%9C%AC%E5%AE%9A%E5%BE%8B.jpg" alt="img" style="max-width:100%;"  /></p>
</li>
<li>
<h3 id="基本规则"><a class="markdownIt-Anchor" href="#基本规则"></a> 基本规则</h3>
<ul>
<li>
<h4 id="带入规则"><a class="markdownIt-Anchor" href="#带入规则"></a> 带入规则</h4>
<p>任何一个还有A变量的等式，如果将所有出现A的位置都带入同一个逻辑函数，则等式成立</p>
<p>例如：</p>
<p>B(A + C) = BA + BC</p>
<p>将A替换成A+D也依然成立：</p>
<p>B[(A+D) + C] = B(A + D) + BC = BA + BD + BC</p>
</li>
<li>
<h4 id="反演规则"><a class="markdownIt-Anchor" href="#反演规则"></a> 反演规则</h4>
<p>反演规则被用于求一个表达式 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi>P</mi></mrow></mrow><annotation encoding="application/x-tex">{P}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span></span></span></span></span> 的<code>非表达式</code><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mrow><mi>P</mi></mrow><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{P}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8833300000000001em;"></span><span class="strut bottom" style="height:0.8833300000000001em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="overline mord"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span></span></span><span style="top:-0.80333em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped overline-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span></span></span></span></p>
<p>规则条件</p>
<ol>
<li>将表达式中的<code>与</code>变<code>或</code>，<code>或</code>变<code>与</code></li>
<li><code>原变量</code>变<code>非变量</code>，<code>非变量</code>变<code>原变量</code></li>
<li>逻辑<code>1</code>变<code>0</code>，<code>0</code>变<code>1</code></li>
</ol>
<p>例如：</p>
<p>已知 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi>F</mi><mo>=</mo></mrow><mover accent="true"><mrow><mi>A</mi><mi>B</mi></mrow><mo stretchy="true">‾</mo></mover><mo>+</mo><mi>C</mi><mi>D</mi></mrow><annotation encoding="application/x-tex">{F=}\overline{AB}+CD</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8833300000000001em;"></span><span class="strut bottom" style="height:0.9666600000000001em;vertical-align:-0.08333em;"></span><span class="base textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="mrel">=</span></span><span class="overline mord"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="mord mathit">A</span><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span><span style="top:-0.80333em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped overline-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit" style="margin-right:0.02778em;">D</span></span></span></span> 求 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mrow><mi>F</mi></mrow><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{F}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8833300000000001em;"></span><span class="strut bottom" style="height:0.8833300000000001em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="overline mord"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="mord mathit" style="margin-right:0.13889em;">F</span></span></span><span style="top:-0.80333em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped overline-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span></span></span></span></p>
<p>根据反演规则可得（注意括号）： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mrow><mi>F</mi></mrow><mo stretchy="true">‾</mo></mover><mo>=</mo><mo>(</mo><mi>A</mi><mo>+</mo><mi>B</mi><mo>)</mo><mo>(</mo><mover accent="true"><mrow><mi>C</mi></mrow><mo stretchy="true">‾</mo></mover><mo>+</mo><mover accent="true"><mrow><mi>D</mi></mrow><mo stretchy="true">‾</mo></mover><mo>)</mo></mrow><annotation encoding="application/x-tex">\overline{F}=(A+B)(\overline{C}+\overline{D})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8833300000000001em;"></span><span class="strut bottom" style="height:1.13333em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="overline mord"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="mord mathit" style="margin-right:0.13889em;">F</span></span></span><span style="top:-0.80333em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped overline-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mopen">(</span><span class="mord mathit">A</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mopen">(</span><span class="overline mord"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="mord mathit" style="margin-right:0.07153em;">C</span></span></span><span style="top:-0.80333em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped overline-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="overline mord"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="mord mathit" style="margin-right:0.02778em;">D</span></span></span><span style="top:-0.80333em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped overline-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span><span class="mclose">)</span></span></span></span></p>
</li>
<li>
<h4 id="对偶规则"><a class="markdownIt-Anchor" href="#对偶规则"></a> 对偶规则</h4>
<p>某个表达式 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi>F</mi></mrow></mrow><annotation encoding="application/x-tex">{F}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">F</span></span></span></span></span> 成立，则其<code>对偶式</code> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><msup><mi>F</mi><mrow><mi mathvariant="normal">′</mi></mrow></msup></mrow></mrow><annotation encoding="application/x-tex">{F&#x27;}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:0.751892em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">′</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span> 也成立</p>
<p>规则条件</p>
<ol>
<li>将表达式中的<code>与</code>变<code>或</code>，<code>或</code>变<code>与</code></li>
<li>逻辑<code>1</code>变<code>0</code>，<code>0</code>变<code>1</code></li>
</ol>
<p>例如</p>
<p>已知 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi>F</mi><mo>=</mo><mo>(</mo><mi>A</mi><mo>+</mo><mover accent="true"><mrow><mi>B</mi></mrow><mo stretchy="true">‾</mo></mover><mo>)</mo><mo>(</mo><mi>A</mi><mo>+</mo><mi>C</mi><mo>)</mo></mrow></mrow><annotation encoding="application/x-tex">{F = (A+\overline{B})(A+C)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8833300000000001em;"></span><span class="strut bottom" style="height:1.13333em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="mrel">=</span><span class="mopen">(</span><span class="mord mathit">A</span><span class="mbin">+</span><span class="overline mord"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span><span style="top:-0.80333em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped overline-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathit">A</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mclose">)</span></span></span></span></span> 求 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><msup><mi>F</mi><mrow><mi mathvariant="normal">′</mi></mrow></msup></mrow></mrow><annotation encoding="application/x-tex">{F&#x27;}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:0.751892em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">′</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span></p>
<p>根据对偶规则可得 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><msup><mi>F</mi><mrow><mi mathvariant="normal">′</mi></mrow></msup><mo>=</mo><mi>A</mi><mover accent="true"><mrow><mi>B</mi></mrow><mo stretchy="true">‾</mo></mover><mo>+</mo><mi>A</mi><mi>C</mi></mrow></mrow><annotation encoding="application/x-tex">{F&#x27; = A\overline{B} + AC}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8833300000000001em;"></span><span class="strut bottom" style="height:0.9666600000000001em;vertical-align:-0.08333em;"></span><span class="base textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">′</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mord mathit">A</span><span class="overline mord"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span><span style="top:-0.80333em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped overline-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord mathit">A</span><span class="mord mathit" style="margin-right:0.07153em;">C</span></span></span></span></span></p>
</li>
</ul>
</li>
<li>
<h3 id="卡诺图"><a class="markdownIt-Anchor" href="#卡诺图"></a> 卡诺图</h3>
<ul>
<li>
<h3 id="最小项"><a class="markdownIt-Anchor" href="#最小项"></a> 最小项</h3>
<p>所谓最小项是指有且仅有一个的表达式，该表达式包含了所有变量的乘积项，含有n个变量的最小项含有n个因子</p>
<p>比如三个变量A,B,C一共有 2<sup>3</sup> = 8 个最小项，分别是</p>
<p><img src="%E6%9C%80%E5%B0%8F%E9%A1%B9.png" alt="img" style="max-width:100%;"  /></p>
</li>
<li>
<h3 id="最小项编号"><a class="markdownIt-Anchor" href="#最小项编号"></a> 最小项编号</h3>
<p>把最小项的取值当成二进制数，再将其转换成十进制数，因此每个最小项的编号是唯一的，最小项编号用字母m加上下标来表示</p>
</li>
<li>
<h3 id="最小项表达式"><a class="markdownIt-Anchor" href="#最小项表达式"></a> 最小项表达式</h3>
<p>由若干个最小项的或运算组合而成，每一个逻辑函数都可以化成最小项表达式</p>
</li>
<li>
<h3 id="通过组合合并最小项并减小变量"><a class="markdownIt-Anchor" href="#通过组合合并最小项并减小变量"></a> 通过组合合并最小项并减小变量</h3>
<p>一般用在得出最小项表达式后进行最小项合并(化简)</p>
<p>步骤：</p>
<ol>
<li>把不是最小项的项通过 * 1 的操作来变成最小项</li>
<li>把最小项表达式中的每一小项填入卡诺图</li>
<li>画出所有组合（一般顺序为：八方格 → 四方格 → 二方格 → 无组合）</li>
<li>根据消去定律消去组合中的变量</li>
<li>把所有消去后的变量相加（或运算）</li>
</ol>
<p><strong>卡诺图的常用组合：</strong></p>
<ul>
<li>
<p>二方格的相邻组合：任何相邻的最小项可合并，且消去一个变量</p>
<p><img src="%E4%BA%8C%E6%96%B9%E6%A0%BC%E7%9B%B8%E9%82%BB%E7%BB%84%E5%90%88.png" alt="img" style="max-width:100%;"  /></p>
</li>
<li>
<p>四方格的相邻组合：4个相邻最小项可合并成一项，且消去两个变量</p>
<p><img src="%E5%9B%9B%E6%96%B9%E6%A0%BC%E7%9B%B8%E9%82%BB%E7%BB%84%E5%90%88.png" alt="img" style="max-width:100%;"  /></p>
</li>
<li>
<p>八方格的相邻组合：8个相邻最小项可合并成一项，且消去三个变量</p>
<p><img src="%E5%85%AB%E6%96%B9%E6%A0%BC%E7%9B%B8%E9%82%BB%E7%BB%84%E5%90%88.png" alt="img" style="max-width:100%;"  /></p>
</li>
</ul>
<p>例子：</p>
<p><img src="%E5%8D%A1%E8%AF%BA%E5%9B%BE%E4%BE%8B%E9%A2%98.png" alt="img" style="max-width:100%;"  /></p>
<p><img src="%E5%8D%A1%E8%AF%BA%E5%9B%BE%E7%AD%94%E6%A1%88.png" alt="img" style="max-width:100%;"  /></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr />
<ul>
<li>
<h2 id="数字逻辑"><a class="markdownIt-Anchor" href="#数字逻辑"></a> 数字逻辑</h2>
<ul>
<li>
<h3 id="组合逻辑"><a class="markdownIt-Anchor" href="#组合逻辑"></a> 组合逻辑</h3>
输出完全由输入决定</li>
<li>
<h3 id="时序逻辑"><a class="markdownIt-Anchor" href="#时序逻辑"></a> 时序逻辑</h3>
输出由输入和上一时刻所处于的状态来决定
<ul>
<li>
<h4 id="锁存器"><a class="markdownIt-Anchor" href="#锁存器"></a> 锁存器</h4>
<p>用于存储上一时刻的状态</p>
<p><code>状态</code>:原先的状态叫<code>原态</code>或<code>现态</code>(PS)，之后的状态叫<code>次态</code>(NS)</p>
</li>
<li>
<h4 id="触发器"><a class="markdownIt-Anchor" href="#触发器"></a> 触发器</h4>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr />
<ul>
<li>
<h2 id="存储系统"><a class="markdownIt-Anchor" href="#存储系统"></a> 存储系统</h2>
<ul>
<li>
<h3 id="存储器的分类"><a class="markdownIt-Anchor" href="#存储器的分类"></a> 存储器的分类：</h3>
<ul>
<li>按存储介质分：磁芯存储器、磁表面存储器、半导体存储器、光存储器</li>
<li>按存取方式分：随机/顺序存取（磁带）</li>
<li>按读写功能分类：ROM，RAM
<ul>
<li>RAM（随机存储）：BJT双极型/MOS单极型，所谓随机存取，是指存取时间与存储单元位置无关，断电丢失数据因此也叫做易失性存储器</li>
<li>ROM（只读存储）：MROM/PROM/EPROM/EEPROM</li>
</ul>
</li>
<li>按信息的可保存性分类：永久性和非永久性的</li>
<li>按存储器系统中的作用分类：主/辅/缓/控</li>
</ul>
<p>对存储器的要求是容量大、速度快、成本低，为了解决这三方面的矛盾，计算机采用多级存储体系结构，即cache、主存、外存</p>
<p>主存储器的技术指标有 存储容量，存取时间，存储周期，存储器带宽。</p>
<p><img src="%E5%AD%98%E5%82%A8%E5%99%A8.png" alt="img" style="max-width:100%;"  /></p>
</li>
<li>
<h3 id="主存储器"><a class="markdownIt-Anchor" href="#主存储器"></a> 主存储器</h3>
<p>主存储器（内部存储器）是半导体存储器，一般采用DRAM的半导体存储器，其中包含了RAM + ROM</p>
<p>主存的结构：</p>
<ul>
<li>存储体：由多个存储元组成，负责存储具体的二进制位</li>
<li>MAR: 存储器地址寄存器，负责接收外部传入的地址信息</li>
<li>MDR：存储器数据寄存器，负责暂存接收或传出的数据信号</li>
</ul>
<p>存储体、MDR、MAR均在<strong>时序控制逻辑</strong>的控制下协调工作</p>
<p><img src="%E4%B8%BB%E5%AD%98%E9%80%BB%E8%BE%91%E5%9B%BE.png" alt="img" style="max-width:100%;"  /></p>
<p>红色的线表示并行控制信号,能并行地控制多个存储元。逻辑上将存储元分组，一行一组，每一组又叫做一个<code>存储单元</code>。</p>
<p>绿色的线表示对存储元的信号进行传入和传出。</p>
<p>在有电的时候才能存在那些电信号（绿色的二进制位），一次取出来的这些电信号叫做一个<code>存储字</code>。根据存储单元设计的不同，存储字的位数可以不同。因此我门把存储字的位数叫做<code>存储字长</code>，像这里的存储位数是8位，那么存储字长就是8bit = 1Byte（一般都会是8的整数倍，因此一般用字节Byte做单位）。</p>
<p>存储体的这种设计也会有一些问题，比如同时在两条红线上放一个读信号，那么每一条绿线上可能会有两个电信号。这将会导致红线可能收到一个不是它想要的信号。</p>
<p>因此这样的存储方式将会收到限制：一次只能使一行的存储单元有效，也就是说一次只能有一条红线表示有效。这会非常浪费资源，因为按理来说一个二进制位应该能表示2<sup>n</sup>种状态，但是我们只需要表示某一个存储单元上的2种状态。</p>
<p>解决这个问题的方式是通过译码器，将n位的二进制地址来表示2<sup>n</sup>个存储单元，以此减少输入控制信息的位数。</p>
<p><img src="%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E7%AE%80%E5%8D%95%E6%A8%A1%E5%9E%8B.png" alt="img" style="max-width:100%;"  /></p>
<p><img src="%E5%AD%98%E5%82%A8%E5%99%A8%E8%8A%AF%E7%89%87%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.png" alt="img" style="max-width:100%;"  /></p>
<p>我们常常把存储体抽象成<code>存储矩阵</code>，一个存储矩阵由多个存储单元构成，像下面的每一个格代表一个存储单元而不是存储元。</p>
<p>通过存储矩阵，我们可以将地址按不同需求分组，如下图。分组之后，可以先找到高位地址部分，再去找低位地址，如蓝色部分是按字寻址，把地址分成了四份，红色框圈起来的就是高位的地址。</p>
<p>分组后应该如何存放一个字呢，还是以按字寻址为例，一个单元4B也就是32位，一般的计算机有两种方法：大端方式和小端方式。大端方式就是指，如果单元头为第一位为12，往后每个单元的地址就是12*n，小端方式就是反过来。</p>
<p><img src="%E5%AF%BB%E5%9D%80.png" alt="img" style="max-width:100%;"  /></p>
</li>
<li>
<h3 id="半导体存储器"><a class="markdownIt-Anchor" href="#半导体存储器"></a> 半导体存储器</h3>
<p><img src="%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%AD%98%E5%82%A8%E8%8A%AF%E7%89%87%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.png" alt="img" style="max-width:100%;"  /></p>
<p>在主存中提到了DRAM，这里详细说一下DRAM和SRAM的区别：</p>
<p>半导体存储器根据信息存储的机理不同可以分为两类：</p>
<ul>
<li>静态读写存储器(SRAM)：采用双译码方式，存取速度快，存储位元是一个触发器</li>
<li>动态读写存储器(DRAM)：存储容量不如SRAM大，存储位元是由一个MOS晶体管和电容器组成的记忆电路</li>
</ul>
<p>具体区别如下</p>
<p><img src="%E5%8D%8A%E5%AF%BC%E4%BD%93%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%8F%96%E5%AD%98%E5%82%A8%E5%99%A8.png" alt="img" style="max-width:100%;"  /></p>
<h4 id="dram"><a class="markdownIt-Anchor" href="#dram"></a> DRAM</h4>
<p>DRAM的最大作用就是能减少选根线的使用数量：</p>
<p><img src="DRAM%E7%9A%84%E5%88%B7%E6%96%B0.png" alt="img" style="max-width:100%;"  /></p>
<p>可以看到，原本需要使用256根选通线的存储器，现在只需要使用32根选通线。由于DRAM能以此选择多个选通线，因此，它能一次刷新多个存储单元</p>
<h4 id="sram"><a class="markdownIt-Anchor" href="#sram"></a> SRAM</h4>
<p><img src="SRAM%E7%9A%84%E8%AF%BB%E5%86%99%E5%91%A8%E6%9C%9F.png" alt="img" style="max-width:100%;"  /></p>
</li>
<li>
<h3 id="rom"><a class="markdownIt-Anchor" href="#rom"></a> ROM</h3>
<p>之前提到，RAM是一种易失性存储器，一旦断电，将会失去信息。CPU的任务是到主存中取指令，然后再按指令的指示进行下一步工作。因此断电后CPU到主存中取指令时将会发生错误。而辅存（硬盘之类的）不能和CPU直接通信，是通过I/O接口连接到主机的，而I/O操作也是需要主存来完成的。因此我门需要另外的能做到断电后不丢失数据，而且能和CPU直接通信的存储器，这就是ROM（只读存储器）。</p>
<p>ROM的作用：存放不同程序的操作指令及各种需要计算、处理的数据，所以它相当于整个电路系统存储信息的仓库。</p>
<p>它可以指出辅存在OS中的位置，并且把I/O接口调到RAM中。完成这一步后CPU再去访问RAM就能收到正确的指令了</p>
<p>ROM各个版本的发展历程：</p>
<p><img src="ROM.png" alt="img" style="max-width:100%;"  /></p>
<p>早期的ROM是只读的，现在的ROM虽然能写，但是速度依然很慢，因此不能用ROM代替RAM</p>
</li>
<li>
<h3 id="并行存储器"><a class="markdownIt-Anchor" href="#并行存储器"></a> 并行存储器</h3>
<p>双端口存储器和多模块交叉存储器属于并行存储器结构，其中前者采用 空间并行技术，后者采用 时间并行技术。</p>
</li>
<li>
<h3 id="cache高速缓冲存储器"><a class="markdownIt-Anchor" href="#cache高速缓冲存储器"></a> Cache高速缓冲存储器</h3>
<h4 id="cache的局部性原理"><a class="markdownIt-Anchor" href="#cache的局部性原理"></a> Cache的局部性原理</h4>
<p>空间局部性：比如一段连续的数组，我这一次可能取的a[1]，那么我下一次有可能取到a[2]，这样每一次存或取都会访问一次主存。</p>
<p>时间局部性：比如for循环遍历数组，我在一次循环中可能取的a[1]，那么我在有可能在下一次循环中取到a[2]，这样每一次取都会访问一次主存。</p>
<p>假设主存的一次的存取时间是1000ns，CPU完成一次+2操作需要5ns，那么执行这一条for语句中的&quot;a[i]=a[i]+2&quot;将耗时：1000 + 1000 + 5 = 20005ns。</p>
<p>我们能看到如果能一次就取出未来要用的数据，那么能很大程度上提高性能。</p>
<p>为了解决时间局部性和空间局部性，我们需要一个小容量但高速的存储器来暂存未来要用的数据块，这个存储器就是<code>Cache</code>。</p>
<p><img src="%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86.png" alt="img" style="max-width:100%;"  /></p>
<p>可以看到通过Cache，整体执行时间少了17倍左右</p>
<p><img src="Cache%E5%91%BD%E4%B8%AD%E7%8E%87.png" alt="img" style="max-width:100%;"  /></p>
<p><img src="Cache%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90.png" alt="img" style="max-width:100%;"  /></p>
<h4 id="cache的地址映射"><a class="markdownIt-Anchor" href="#cache的地址映射"></a> Cache的地址映射</h4>
<p>之前提到了Cache把主存的数据以块的方式暂存起来，那么我们来思考三个问题：</p>
<ol>
<li>主存中的块放到Cache中的哪个位置？</li>
</ol>
<ul>
<li>(1) 全相联映射：空位随意放</li>
<li>(2) 直接映射：对号入座</li>
<li>(3) 组相联映射：按号分组，组内随意放</li>
</ul>
<ol start="2">
<li>对于(1)当Cache满了怎么办，对于(2)(3)位置被占用时怎么办</li>
</ol>
<p>对于这种情况，无非就是要把哪个占了位置的家伙踢走，常用的策略有：</p>
<ul>
<li>随机(RAND)算法：随机踢一个</li>
<li>先进先出(FIFO)算法：踢最先进来的那个</li>
<li>最近最久未使用(LRU)算法：踢最久没用到的那个</li>
<li>最近最少使用(LFU)算法：踢用的最少的那个</li>
</ul>
<ol start="3">
<li>修改Cache中的内容后，如何保持主存中对应内容的一致性？</li>
</ol>
<p>分两种情况讨论，当命中时；当不命中时。</p>
</li>
<li>
<h3 id="虚拟存储器"><a class="markdownIt-Anchor" href="#虚拟存储器"></a> 虚拟存储器</h3>
<p>虚拟存储，就是把 内存 与 外存 有机的结合起来使用，从而得到一个容量很大的“内存”，这就称之为虚拟存储。</p>
<p>虚拟存储器是一个逻辑模型，它对操作系统来说是透明的。</p>
<p>它的功能是：用户给出一个地址，叫做<code>虚地址</code>（逻辑地址），虚拟存储器要给出该地址对应的数据并反馈给用户。</p>
<p>虚拟存储器由辅助硬件将<code>虚地址</code> 映射 到主存当中的某个单元，主存单元的地址又被称为<code>实地址</code>（物理地址）。</p>
</li>
</ul>
</li>
</ul>
<hr />
<ul>
<li>
<h2 id="指令系统"><a class="markdownIt-Anchor" href="#指令系统"></a> 指令系统</h2>
<p>一条指令就是机器语言中的一个语句，它是一组有意义的二进制代码。</p>
<p>一条指令通常要包括<code>操作码字段(OP)</code>和<code>地址码字段(A)</code>两个部分</p>
<p>操作码表示用户要干什么，而地址码表示要对谁进行操作</p>
<p>一个较为完善的指令系统，应当由数据处理、数据存储、数据传送、程序控制 这四大指令</p>
<ul>
<li>
<h3 id="指令格式"><a class="markdownIt-Anchor" href="#指令格式"></a> 指令格式</h3>
<p>比如下面的指令是一条四地址的指令，它的含义是指把A1 和 A2 取出来，进行OP操作，把计算结果存放到A3中，然后从A4中取出下一条指令</p>
<p><img src="%E5%9B%9B%E5%9C%B0%E5%9D%80%E6%8C%87%E4%BB%A4.png" alt="img" style="max-width:100%;"  /></p>
<p>我们发现可以单独把指令和地址分开放，那么每次执行完这条指令就自动取下一条连续的指令就可以了，这就简化成三地址指令，如下。</p>
<p><img src="%E4%B8%89%E5%9C%B0%E5%9D%80%E6%8C%87%E4%BB%A4.png" alt="img" style="max-width:100%;"  /></p>
<p>如果把A1和A2完成计算后把结果放到A1上将其覆盖，那么还可以简化成二地址指令</p>
<p>如果操作数本身只有一个或者另外一个操作数是隐含约定的目的地址，那么可以再简化成一指令地址</p>
<p>还有一种地址指令，它不需要操作数因此，可以简化成零指令地址</p>
<p><img src="%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F.png" alt="img" style="max-width:100%;"  /></p>
</li>
<li>
<h3 id="指令寻址"><a class="markdownIt-Anchor" href="#指令寻址"></a> 指令寻址</h3>
<p>指令寻址有2种（顺序型，跳跃型）</p>
<p><img src="%E6%8C%87%E4%BB%A4%E5%AF%BB%E5%9D%80.png" alt="img" style="max-width:100%;"  /></p>
</li>
<li>
<h3 id="数据寻址"><a class="markdownIt-Anchor" href="#数据寻址"></a> 数据寻址</h3>
<p>数据寻址有8种（隐含、立即，直接，间接，寄存器直接，寄存器间接，偏移寻址（相对寻址、基质址址、变址寻址），堆栈寻址</p>
<p>寻址特征表明了该操作数采用哪种数据寻址方式；形式地址根据寻址特征的不同，有不一样的含义</p>
<p><img src="%E6%95%B0%E6%8D%AE%E5%AF%BB%E5%9D%80%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F.png" alt="img" style="max-width:100%;"  /></p>
<ul>
<li>
<h4 id="立即寻址"><a class="markdownIt-Anchor" href="#立即寻址"></a> 立即寻址</h4>
<p>形式地址就是操作数本身，一般采用补码形式</p>
<p><img src="%E7%AB%8B%E5%8D%B3%E5%AF%BB%E5%9D%80.png" alt="img" style="max-width:100%;"  /></p>
</li>
<li>
<h4 id="直接寻址"><a class="markdownIt-Anchor" href="#直接寻址"></a> 直接寻址</h4>
<p>形式地址就是操作数的在主存中真实地址</p>
<p><img src="%E7%9B%B4%E6%8E%A5%E5%AF%BB%E5%9D%80.png" alt="img" style="max-width:100%;"  /></p>
</li>
<li>
<h4 id="间接寻址"><a class="markdownIt-Anchor" href="#间接寻址"></a> 间接寻址</h4>
<p>形式地址是操作数在主存中地址的地址（套娃）</p>
<p><img src="%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80.png" alt="img" style="max-width:100%;"  /></p>
</li>
<li>
<h4 id="寄存器寻址寄存器直接寻址"><a class="markdownIt-Anchor" href="#寄存器寻址寄存器直接寻址"></a> 寄存器寻址（寄存器直接寻址）</h4>
<p>和直接寻址类似，只不过形式地址是操作数所在在寄存器中的地址（寄存器的编号）</p>
<p><img src="%E5%AF%84%E5%AD%98%E5%99%A8%E5%AF%BB%E5%9D%80.png" alt="img" style="max-width:100%;"  /></p>
</li>
<li>
<h4 id="寄存器间接寻址"><a class="markdownIt-Anchor" href="#寄存器间接寻址"></a> 寄存器间接寻址</h4>
<p>和间接寻址类似，操作数地址仍然是在主存中的，但操作数地址的地址是由寄存器所给出的</p>
<p><img src="%E5%AF%84%E5%AD%98%E5%99%A8%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80.png" alt="img" style="max-width:100%;"  /></p>
</li>
<li>
<h4 id="隐含寻址"><a class="markdownIt-Anchor" href="#隐含寻址"></a> 隐含寻址</h4>
<p>在指令中隐含着操作数的地址。如单地址的指令格式，就不是明显地在地址字段中指出第二个操作数的地址，而是规定累加器ACC作为第二操作数，指令格式明显指出的仅是第一操作数的地址。因此，累加器ACC对单地址指令格式来说是隐含地址。</p>
<p><img src="%E9%9A%90%E5%90%AB%E5%AF%BB%E5%9D%80.png" alt="img" style="max-width:100%;"  /></p>
</li>
<li>
<h4 id="偏移寻址"><a class="markdownIt-Anchor" href="#偏移寻址"></a> 偏移寻址</h4>
<p>偏移寻址其实就是对寄存器中的内容再加上一个偏移量A（形式地址），所得到的一个新的地址作为操作数的有效地址</p>
<p><img src="%E5%81%8F%E7%A7%BB%E5%AF%BB%E5%9D%80.png" alt="img" style="max-width:100%;"  /></p>
<p>偏移寻址又可以分为相对寻址、基质址址、变址寻址</p>
<ul>
<li>
<h5 id="基址寻址"><a class="markdownIt-Anchor" href="#基址寻址"></a> 基址寻址</h5>
<p>将 <strong>指令字中的形式地址</strong> 和 <strong>BR寄存器中的内容取出来</strong> 通过 <strong>ALU</strong> 进行相加，就得到了操作数的有效地址</p>
<p><img src="%E5%9F%BA%E5%9D%80%E5%AF%BB%E5%9D%80.png" alt="img" style="max-width:100%;"  /></p>
</li>
<li>
<h4 id="变址寻址"><a class="markdownIt-Anchor" href="#变址寻址"></a> 变址寻址</h4>
<p>将 <strong>指令字中的形式地址</strong> 和 <strong>IX寄存器中的内容取出来</strong> 通过 <strong>ALU</strong> 进行相加，就得到了操作数的有效地址</p>
<p><img src="%E5%8F%98%E5%9D%80%E5%AF%BB%E5%9D%80.png" alt="img" style="max-width:100%;"  /></p>
</li>
<li>
<h4 id="相对寻址"><a class="markdownIt-Anchor" href="#相对寻址"></a> 相对寻址</h4>
<p>将 <strong>指令字中的形式地址</strong> 和 <strong>PC寄存器中的内容取出来</strong> 通过 <strong>ALU</strong> 进行相加，就得到了操作数的有效地址</p>
<p>注意PC取值后会进行自增运算</p>
<p><img src="%E7%9B%B8%E5%AF%B9%E5%AF%BB%E5%9D%80.png" alt="img" style="max-width:100%;"  /></p>
<p><img src="%E7%9B%B8%E5%AF%B9%E5%AF%BB%E5%9D%80%E4%B8%BE%E4%BE%8B.png" alt="img" style="max-width:100%;"  /></p>
</li>
<li>
<h4 id="堆栈寻址"><a class="markdownIt-Anchor" href="#堆栈寻址"></a> 堆栈寻址</h4>
<p><img src="%E5%A0%86%E6%A0%88%E5%AF%BB%E5%9D%80.png" alt="img" style="max-width:100%;"  /></p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<h3 id="cisc和risc"><a class="markdownIt-Anchor" href="#cisc和risc"></a> CISC和RISC</h3>
<p><img src="CISC%E5%92%8CRISC.png" alt="img" style="max-width:100%;"  /></p>
<p><img src="CISC%E5%92%8CRISC%E5%AF%B9%E6%AF%94%E5%9B%BE.png" alt="img" style="max-width:100%;"  /></p>
</li>
</ul>
</li>
</ul>
<hr />
<ul>
<li>
<h2 id="中央处理器cpu"><a class="markdownIt-Anchor" href="#中央处理器cpu"></a> 中央处理器CPU</h2>
<p>中央处理器CPU = 运算器 + cache + 控制器 ，它的主要功能如下：</p>
<p><img src="CPU%E7%9A%84%E5%8A%9F%E8%83%BD.png" alt="img" style="max-width:100%;"  /></p>
<p>运算器主要对数据进行加工，控制器主要控制计算机各个部件的执行程序的指令序列，基本功能包括：取指令、分析指令、执行指令</p>
<p>运算器:算术逻辑单元(ALU)、通用寄存器(R0～R3)、数据缓冲寄存器(DR)、状态字寄存器(PSW)</p>
<p><img src="ALU%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.png" alt="img" style="max-width:100%;"  /></p>
<p>控制器组成：程序计数器(PC)、指令寄存器(IR)、数据缓冲器(DR)、地址寄存器(AR)、通用寄存器(R0~R3)、状态寄存器(PSW)、时序发生器、指令译码器、总线（数据通路）</p>
<p><img src="%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.png" alt="img" style="max-width:100%;"  /></p>
<p>cache：</p>
<ul>
<li>指令cache：PC，IBUS</li>
<li>数据cache：AR，DBUS</li>
</ul>
<p><img src="CPU%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.png" alt="img" style="max-width:100%;"  /></p>
<ul>
<li>
<h3 id="指令周期和数据流"><a class="markdownIt-Anchor" href="#指令周期和数据流"></a> 指令周期和数据流</h3>
<p>CPU从 主存 取出一条指令并执行这条指令的时间和称为 指令周期。</p>
<p>CPU周期通常又称机器周期，一个机器周期又由多个时钟周期组成</p>
<p>通常把一条指令周期划分为若干个机器周期，每个机器周期完成一个基本操作。</p>
<p><img src="%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F.png" alt="img" style="max-width:100%;"  /></p>
<p>指令周期流程</p>
<ol>
<li>取指周期：取指令（读操作）</li>
</ol>
<p><img src="%E5%8F%96%E5%9D%80%E5%91%A8%E6%9C%9F.png" alt="img" style="max-width:100%;"  /></p>
<ol>
<li>间址周期：取有效地址（读操作）</li>
</ol>
<p><img src="%E9%97%B4%E5%9D%80%E5%91%A8%E6%9C%9F.png" alt="img" style="max-width:100%;"  /></p>
<ol>
<li>执行周期：取操作数（读操作）</li>
</ol>
<p><img src="%E6%89%A7%E8%A1%8C%E5%91%A8%E6%9C%9F.png" alt="img" style="max-width:100%;"  /></p>
<ol>
<li>中断周期：保护程序断点（写操作）</li>
</ol>
<p><img src="%E4%B8%AD%E6%96%AD%E5%91%A8%E6%9C%9F.png" alt="img" style="max-width:100%;"  /></p>
</li>
<li>
<h3 id="硬布线控制器的设计"><a class="markdownIt-Anchor" href="#硬布线控制器的设计"></a> 硬布线控制器的设计</h3>
<p>CU的第一种设计方案</p>
<p>控制方式：控制不同操作序列时序信号的方法</p>
<ol>
<li>
<p>同步控制方式（指令的机器周期和时钟周期数不变）</p>
<ul>
<li>完全统一的机器周期执行各种不同的指令</li>
<li>采用不定长机器周期</li>
<li>中央控制于局部控制的结合</li>
</ul>
</li>
<li>
<p>异步控制方式</p>
</li>
</ol>
<p>每条指令需要多长时间就占多长时间</p>
<p>3 联合控制方式</p>
<ul>
<li>大部分指令在固定的周期内完成，少数难以确定的操作采用异步方式</li>
<li>机器周期的节拍脉冲固定，但是各指令的机器周期数不固定（微程序控制器采用）</li>
</ul>
</li>
<li>
<h3 id="微程序控制器的设计"><a class="markdownIt-Anchor" href="#微程序控制器的设计"></a> 微程序控制器的设计</h3>
<p>CU的第二种设计方案</p>
<p>一些基本概念：</p>
<ul>
<li>
<p>微指令:</p>
<p>把在同一CPU周期内并行执行的微操作控制信息，存储在控制存储器里，称为一条微指令</p>
</li>
<li>
<p>微程序:</p>
<p>一系列微指令的有序集合就是微程序。一段微程序对应一条机器指令，每条机器指令由一段微指令编程的微程序来解释执行.</p>
</li>
<li>
<p>微地址:</p>
<p>存放微指令的控制存储器的单元地址</p>
</li>
<li>
<p>微命令：</p>
<p>控制部件向执行部件发出的各种控制命令叫作微命令，它是构成控制序列的最小单位。</p>
</li>
<li>
<p>微操作：</p>
<p>是微命令的操作过程。</p>
</li>
</ul>
<p>事先把微操作控制信号存储在一个专门的存储器（控制存储器）中，将每一条机器指令编写成一个微程序，这些微程序可以存到一个控制存储器中，用寻址用户程序机器指令的办法来寻址每个微程序中的微指令。</p>
<p>为确定下一条微指令的地址，通常采用断定方式，其基本思想是通过微指令顺序控制字段由设计者指定或由设计者指定的判别字段控制产生后继微指令地址</p>
</li>
</ul>
</li>
</ul>
<hr />
<ul>
<li>
<h2 id="总线"><a class="markdownIt-Anchor" href="#总线"></a> 总线</h2>
<p>定义：总线是一组能为多个部件分时共享的公共信息传送线路。分时是指不同的设备在不同时刻获得总线的使用权</p>
<p>为什么使用总线：早期的计算机外部设备大多使用分散连接的方式，不易实现随时增减外部设备</p>
<p>总线的特性：</p>
<p><img src="%E6%80%BB%E7%BA%BF%E7%9A%84%E7%89%B9%E6%80%A7.png" alt="img" style="max-width:100%;"  /></p>
<p>总线的分类</p>
<p><img src="%E6%80%BB%E7%BA%BF%E7%9A%84%E5%88%86%E7%B1%BB.png" alt="img" style="max-width:100%;"  /></p>
<ul>
<li>
<h3 id="总线的仲裁"><a class="markdownIt-Anchor" href="#总线的仲裁"></a> 总线的仲裁</h3>
<p>总线作为一种共享设备，不可避免地会出现同一时刻有多个设备竞争总线控制权的问题，因此需要实现总线仲裁。</p>
<p><strong>总线仲裁的定义：</strong></p>
<p>多个主设备同时竞争主线控制权时，以某种方式选择一个主设备优先获得总线控制权称为总线仲裁。</p>
<p>总线仲裁方式的分类：</p>
<ol>
<li>
<h4 id="集中仲裁"><a class="markdownIt-Anchor" href="#集中仲裁"></a> 集中仲裁</h4>
</li>
</ol>
<ul>
<li>
<p><strong>链式查询（菊花链）：</strong></p>
<p>离总线控制器越近的部件，其优先级越高；离总线控制器越远的部件，其优先级越低</p>
<p>优点</p>
<pre><code> 1.链式查询优先级固定
 2.只需要少数控制线就能按一定优先次序实现总线控制，结构简单，扩产容易
</code></pre>
<p>缺点</p>
<pre><code> 1.对硬件电路的故障敏感，并且优先级不能改变
 2.当优先级高的部件频繁请求使用总线时，会使优先级较低的部件长期不能使用总线
</code></pre>
</li>
<li>
<p><strong>计数器定时查询</strong></p>
<p>用一个计数器控制总线使用权，相对链式查询方式多了一组设备地址线，少了一根总线响应线BG，它们仍公用一根总线请求线BR</p>
<p>优点</p>
<pre><code> 1.计数器的初始值可以改变优先次序
 2.对电路的故障没有链式敏感
</code></pre>
<p>缺点：</p>
<pre><code> 1.增加了控制线数
 2.控制相对比链式查询复杂
</code></pre>
</li>
<li>
<p><strong>独立请求</strong></p>
<p>每一个设备均有一对总线请求BR和总线允许线BG</p>
<p>优点</p>
<pre><code> 1.响应速度快，总线允许信号BG直接从控制器发送到有关设备，不必在设备间传递或者查询
 2.对优先次序的控制相当灵活。
</code></pre>
<p>缺点</p>
<pre><code> 1.控制数量多，若设备有n个，则需要2n+1条控制线。其中+1为BS线，其用处为，用于设备向总线控制部件反馈已经使用完毕总线
 2.总线的控制逻辑更加复杂
</code></pre>
</li>
</ul>
<ol start="2">
<li>
<h4 id="分布仲裁"><a class="markdownIt-Anchor" href="#分布仲裁"></a> 分布仲裁</h4>
</li>
</ol>
<p>不需要中央处理器，每个潜在的主模块都有自己的仲裁器和仲裁号，多个仲裁器竞争使用总线。</p>
<p>工作流程：</p>
<ol>
<li>当设备有总线请求时，它们就把各自唯一的仲裁号发送到共享的仲裁总线上；</li>
<li>每个仲裁器将从仲裁总线上得到的仲裁号与自己的仲裁号进行比较；</li>
<li>如果仲裁总线上的号的优先级高，则它的总线请求不予响应，并撤销它的仲裁号；</li>
<li>最后，获胜者的仲裁号保留在仲裁总线上。</li>
</ol>
</li>
</ul>
</li>
<li>
<h2 id="io系统"><a class="markdownIt-Anchor" href="#io系统"></a> I/O系统</h2>
<p>外围设备的定时方式和信息交换方式:</p>
<ul>
<li>
<p>程序查询方式</p>
</li>
<li>
<p>程序中断方式</p>
</li>
<li>
<p>DMA方式</p>
</li>
<li>
<p>通道方式</p>
</li>
<li>
<h3 id="程序查询方式"><a class="markdownIt-Anchor" href="#程序查询方式"></a> 程序查询方式</h3>
</li>
<li>
<h3 id="程序中断方式"><a class="markdownIt-Anchor" href="#程序中断方式"></a> 程序中断方式</h3>
<p>程序中断是指，在计算机执行现行程序的过程中，出现某些急需处理的异常情况或特殊情况，CPU暂时中止现行程序，而转去处理异常或特殊请求，处理完毕后又自动返回到现行程序的断点处，继续执行原程序。</p>
<p>中断请求可以根据中断信号的来源分为 内中断 和 外中断</p>
<p><img src="%E4%B8%AD%E6%96%AD%E8%AF%B7%E6%B1%82%E7%9A%84%E5%88%86%E7%B1%BB.png" alt="img" style="max-width:100%;"  /></p>
<p>发生中断请求的条件可能是 一次I/O操作结束、机器内部发生故障、一次DMA操作结束</p>
<p>CPU响应中断请求的条件：</p>
<ol>
<li>中断源有中断请求</li>
<li>CPU开中断（允许中断）</li>
<li>一条指令执行完毕，且没用更紧迫的任务</li>
</ol>
<p>中断判优可以由硬件（硬件排队器）实现，也可以由软件（查询程序）实现</p>
<p>中断隐指令：由硬件完成的软件无法完成保存PC的任务</p>
<p>程序中断的过程：</p>
<p><img src="%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%96%AD%E7%9A%84%E8%BF%87%E7%A8%8B.png" alt="img" style="max-width:100%;"  /></p>
<h4 id="中断隐指令的主要任务"><a class="markdownIt-Anchor" href="#中断隐指令的主要任务"></a> 中断隐指令的主要任务</h4>
<ol>
<li>关中断</li>
<li>保存断点</li>
<li>引出中断服务程序：软件查询法、硬件向量法</li>
</ol>
<p>硬件向量法是指 由 硬件 产生 的 向量地址，再由 向量地址 找到中断服务程序入口地址（也就是说向量地址是地址的地址）</p>
</li>
<li>
<h3 id="dma方式"><a class="markdownIt-Anchor" href="#dma方式"></a> DMA方式</h3>
<p>直接存储器访问（Direct Memory Address）DMA方式是为了在主存储器与I／O设备间高速交换批量数据而设置的。</p>
<p>基本思想是：通过硬件控制实现主存与I／O设备间的直接数据传送，在传送过程中无需CPU的干预。数据传送是在DMA控制器控制下进行的，</p>
<p>DMA 控制器按其结构,分为 选择型DMA 控制器和 多路型DMA 控制器。 前者适用于高速设备,后者适用于慢速设备。</p>
<p>采用DMA方式传送数据时，每传送一个数据，就要占用一个 存储周期 的时间。</p>
</li>
</ul>
</li>
</ul>

    </div>
    
    <div class="footer">
    <hr>
        <font> ©2021 </font>
        <a target="_blank" rel="noopener" href="https://github.com/Gatongone/" style="color: rgb(214, 207, 218);">Gatongone</a>
        some copyrights reserved
        <div style="float: right; margin-right: -200px;">
              Jun 21st  2021,  5:00:07  |
            <font>Powered by</font>
            <a target="_blank" rel="noopener" href="https://hexo.io/"  style="color: rgb(214, 207, 218);">Hexo</a>
            framework
        </div>
    </div>
</body>
    



</div>



<script>
     var bar=document.getElementById("top_btn")
     var showtime=0;
     var hidetime=0;
     window.addEventListener("pageshow",function(){
         let scrollTop = window.pageYOffset ||document.documentElement.scrollTop|| document.body.scrollTop || 0;
        if(scrollTop ==0)
        {
            bar.style.display = 'none';
        }
        else
        {
            bar.style.display = 'block';
        }
        window.addEventListener("scroll",function(){
            bar.style.display = 'block';
            scrollTop = window.pageYOffset ||document.documentElement.scrollTop|| document.body.scrollTop || 0;
            if(scrollTop != 0)
            {
                if(hidetime==0)
                {
                    bar.classList.toggle("top_btn_show");
                    hidetime++;
                }
                showtime=0;
            }  
            else
            {
                if(showtime==0 && hidetime!=0)
                {
                    bar.classList.toggle("top_btn_show");
                    showtime++;
                    hidetime=0;
                }
            }
        }) 
     })
     
    var timer = null;
    bar.onclick = function()
    {
        cancelAnimationFrame(timer);
        timer = requestAnimationFrame(function fn()
        {
            var top = document.body.scrollTop || document.documentElement.scrollTop;
            if(top > 0)
            {
                document.body.scrollTop = document.documentElement.scrollTop = top - 80;
                timer = requestAnimationFrame(fn);
            }
            else
            {
                cancelAnimationFrame(timer);
            } 
        });
    }
         
</script>


<script src="//cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.js"></script>

<script src="/blog/js/showpost.js"></script>

<script>
    hljs.initHighlightingOnLoad();
</script>


</body>                                             <!--  加载主体  -->

        </div>                                                                 
        
<script src="/blog/js/searchbar.js"></script>
<script src="/blog/js/hidebar.js"></script>
              <!--    加载JS  -->                                                          
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
</body>

</html>